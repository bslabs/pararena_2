/*============================================================*//*============================================================*//*==														==*//*==			Assembler Rendering Routines				==*//*==														==*//*============================================================*//*============================================================*//*========================================================  Includes  */#include "Globals.h"#include "UnivUtilities.h"#include "RenderAsm4.h"/*========================================================  Functions  *//*========================================================  DropDoorToWorkMapAsm4  */void DropDoorToWorkMapAsm4 (void){	long			srcAddress, destAddress;	srcAddress = theDoor.srcAddrs[theDoor.doorOpen][theDoor.doorState];	destAddress = theDoor.workDestAddr[theDoor.doorOpen];		asm 68000	{		move.l		srcAddress, a0		; src bitmap address		move.l		destAddress, a1		; dest screen address										; 0 = source   1 = dest		move.w		partsRowBytes, d0	; next row offset		move.w		workRowBytes, d1	; next row offset		subi.w		#12, d0				; compensate for (a0)+ increment		subi.w		#12, d1				; compensate for (a1)+ increment		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0),(a1)			; move row 12		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0),(a1)			; move row 13		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0),(a1)			; move row 14		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0),(a1)			; move row 15		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0),(a1)			; move row 16		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0),(a1)			; move row 17		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0),(a1)			; move row 18		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0),(a1)			; move row 19		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0),(a1)			; move row 20		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0),(a1)			; move row 21	}		destAddress = theDoor.backDestAddr[theDoor.doorOpen];	asm 68000	{		move.l		srcAddress, a0		; src bitmap address		move.l		destAddress, a1		; dest screen address										; 0 = source   1 = dest		move.w		partsRowBytes, d0	; next row offset		move.w		backRowBytes, d1	; next row offset		subi.w		#12, d0				; compensate for (a0)+ increment		subi.w		#12, d1				; compensate for (a1)+ increment		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0),(a1)			; move row 12		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0),(a1)			; move row 13		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0),(a1)			; move row 14		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0),(a1)			; move row 15		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0),(a1)			; move row 16		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0),(a1)			; move row 17		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0),(a1)			; move row 18		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0),(a1)			; move row 19		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0),(a1)			; move row 20		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0),(a1)			; move row 21	}}/*========================================================  MaskBoardCursorAsm4  */void MaskBoardCursorAsm4 (long dest, short shiftRight){	asm 68000	{		move.l		a2, -(sp)			; save a2 on stack		move.l		d3, -(sp)			; save d3 on stack		move.l		d4, -(sp)			; save d4 on stack		move.l		d5, -(sp)			; save d5 on stack		move.l		d6, -(sp)			; save d4 on stack		move.l		d7, -(sp)			; save d5 on stack				move.l		boardCursor.srcAddr, a0		; src bitmap address		move.l		dest, a1					; dest screen address		move.l		boardCursor.maskAddr, a2	; mask bitmap address				move.w		partsRowBytes, d0	; next row offset (parts)		subq.l		#4, d0				; compensate for little adds		move.w		workRowBytes, d1	; next row offset		subq.l		#4, d1				; compensate for little adds		move.w		shiftRight, d2		; d2 will hold # of bits to shift right		move.w		#32, d3				; prepare to subtract from 32		sub.w		d2, d3				; calculate value to shift left in d3										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask/parts row diff.										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask/parts row diff.										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask/parts row diff.										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask/parts row diff.										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask/parts row diff.										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask/parts row diff.										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask/parts row diff.										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask/parts row diff.										;		move.l		(sp)+, d7			; restore d5 from stack		move.l		(sp)+, d6			; restore d4 from stack		move.l		(sp)+, d5			; restore d5 from stack		move.l		(sp)+, d4			; restore d4 from stack		move.l		(sp)+, d3			; restore d3 from stack		move.l		(sp)+, a2			; restore a2 from stack	}}/*========================================================  MaskBallAsm4  */void MaskBallAsm4 (long dest, short shiftRight){	asm 68000	{		move.l		a2, -(sp)			; save a2 on stack		move.l		d3, -(sp)			; save d3 on stack		move.l		d4, -(sp)			; save d4 on stack		move.l		d5, -(sp)			; save d5 on stack		move.l		d6, -(sp)			; save d4 on stack		move.l		d7, -(sp)			; save d5 on stack				move.l		ballSrcAddr, a0		; src bitmap address		move.l		dest, a1			; dest screen address		move.l		ballMaskAddr, a2	; mask bitmap address				move.w		partsRowBytes, d0	; next row offset (parts)		subq.l		#4, d0				; compensate for little adds		move.w		workRowBytes, d1	; next row offset		subq.l		#4, d1				; compensate for little adds		move.w		shiftRight, d2		; d2 will hold # of bits to shift right		move.w		#32, d3				; prepare to subtract from 32		sub.w		d2, d3				; calculate value to shift left in d3										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; === prepare for next word		move.l		(a2)+, d6			; move mask row 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src row 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the left		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;		move.l		(sp)+, d7			; restore d5 from stack		move.l		(sp)+, d6			; restore d4 from stack		move.l		(sp)+, d5			; restore d5 from stack		move.l		(sp)+, d4			; restore d4 from stack		move.l		(sp)+, d3			; restore d3 from stack		move.l		(sp)+, a2			; restore a2 from stack	}}/*========================================================  MaskPlayerAsm4  */void MaskPlayerAsm4 (long src, long dest, long mask, short shiftRight){	asm 68000	{		move.l		a2, -(sp)			; save a2 on stack		move.l		d3, -(sp)			; save d3 on stack		move.l		d4, -(sp)			; save d4 on stack		move.l		d5, -(sp)			; save d5 on stack		move.l		d6, -(sp)			; save d4 on stack		move.l		d7, -(sp)			; save d5 on stack				move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address		move.l		mask, a2			; mask bitmap address				move.w		partsRowBytes, d0	; next row offset (parts)		sub.w		#12, d0				; compensate for little adds		move.w		workRowBytes, d1	; next row offset		sub.w		#12, d1				; compensate for little adds		move.w		shiftRight, d2		; d2 will hold # of bits to shift right		move.w		#32, d3				; prepare to subtract from 32		sub.w		d2, d3				; calculate value to shift left in d3										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										; === increment pointers		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#40, a2				; compensate for mask row bytes difference										;										; === BEGIN a ROW		move.l		(a2), d4			; move mask seg 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src seg 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask bits		and.l		d4, (a1)			; and mask to dest (create hole)		or.l		d5, (a1)+			; or src to dest (fill hole)										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 1		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 1		lsl.l		d3, d7				; shift d7 logically d3 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask seg 2		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 2		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 2		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 2		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 3		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 3		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)+			; or src to dest										; <<< prepare for next word		move.l		(a2)+, d6			; move mask seg 3		lsl.l		d3, d6				; shift d6 logically d3 bits to the left		move.l		(a0)+, d7			; move src seg 3		lsl.l		d3, d7				; shift d7 logically d2 bits to the right		and.l		d6, d7				; clear trash bits										; === load next word in row		move.l		(a2), d4			; move mask row 4		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 4		lsr.l		d2, d5				; shift d5 logically d2 bits to the right										; === add overhang from last word in		or.l		d6, d4				; or old mask to new mask		or.l		d7, d5				; or old src to new src		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest										;		move.l		(sp)+, d7			; restore d7 from stack		move.l		(sp)+, d6			; restore d6 from stack		move.l		(sp)+, d5			; restore d5 from stack		move.l		(sp)+, d4			; restore d4 from stack		move.l		(sp)+, d3			; restore d3 from stack		move.l		(sp)+, a2			; restore a2 from stack	}}/*========================================================  DumpWholePlayerAsm4  */void DumpWholePlayerAsm4 (long src, long dest){	asm 68000	{		move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address										; 0 = source   1 = dest		move.w		workRowBytes, d0	; next row offset		move.w		screenRowBytes, d1	; next row offset		subi.w		#16, d0				; compensate for (a0)+ inc. (4 x +'s)		subi.w		#16, d1				; compensate for (a1)+ increment		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0),(a1)			; move row 12		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0),(a1)			; move row 13		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0),(a1)			; move row 14		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0),(a1)			; move row 15		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0),(a1)			; move row 16		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0),(a1)			; move row 17		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0),(a1)			; move row 18		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0),(a1)			; move row 19		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0),(a1)			; move row 20		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0),(a1)			; move row 21		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 22		move.l		(a0)+,(a1)+			; move row 22		move.l		(a0)+,(a1)+			; move row 22		move.l		(a0)+,(a1)+			; move row 22		move.l		(a0),(a1)			; move row 22		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 23		move.l		(a0)+,(a1)+			; move row 23		move.l		(a0)+,(a1)+			; move row 23		move.l		(a0)+,(a1)+			; move row 23		move.l		(a0),(a1)			; move row 23		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 24		move.l		(a0)+,(a1)+			; move row 24		move.l		(a0)+,(a1)+			; move row 24		move.l		(a0)+,(a1)+			; move row 24		move.l		(a0),(a1)			; move row 24		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 25		move.l		(a0)+,(a1)+			; move row 25		move.l		(a0)+,(a1)+			; move row 25		move.l		(a0)+,(a1)+			; move row 25		move.l		(a0),(a1)			; move row 25		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 26		move.l		(a0)+,(a1)+			; move row 26		move.l		(a0)+,(a1)+			; move row 26		move.l		(a0)+,(a1)+			; move row 26		move.l		(a0),(a1)			; move row 26		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 27		move.l		(a0)+,(a1)+			; move row 27		move.l		(a0)+,(a1)+			; move row 27		move.l		(a0)+,(a1)+			; move row 27		move.l		(a0),(a1)			; move row 27		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 28		move.l		(a0)+,(a1)+			; move row 28		move.l		(a0)+,(a1)+			; move row 28		move.l		(a0)+,(a1)+			; move row 28		move.l		(a0),(a1)			; move row 28		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 29		move.l		(a0)+,(a1)+			; move row 29		move.l		(a0)+,(a1)+			; move row 29		move.l		(a0)+,(a1)+			; move row 29		move.l		(a0),(a1)			; move row 29		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 30		move.l		(a0)+,(a1)+			; move row 30		move.l		(a0)+,(a1)+			; move row 30		move.l		(a0)+,(a1)+			; move row 30		move.l		(a0),(a1)			; move row 30		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 31		move.l		(a0)+,(a1)+			; move row 31		move.l		(a0)+,(a1)+			; move row 31		move.l		(a0)+,(a1)+			; move row 31		move.l		(a0),(a1)			; move row 31		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 32		move.l		(a0)+,(a1)+			; move row 32		move.l		(a0)+,(a1)+			; move row 32		move.l		(a0)+,(a1)+			; move row 32		move.l		(a0),(a1)			; move row 32		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 33		move.l		(a0)+,(a1)+			; move row 33		move.l		(a0)+,(a1)+			; move row 33		move.l		(a0)+,(a1)+			; move row 33		move.l		(a0),(a1)			; move row 33		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 34		move.l		(a0)+,(a1)+			; move row 34		move.l		(a0)+,(a1)+			; move row 34		move.l		(a0)+,(a1)+			; move row 34		move.l		(a0),(a1)			; move row 34		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 35		move.l		(a0)+,(a1)+			; move row 35		move.l		(a0)+,(a1)+			; move row 35		move.l		(a0)+,(a1)+			; move row 35		move.l		(a0),(a1)			; move row 35		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 36		move.l		(a0)+,(a1)+			; move row 36		move.l		(a0)+,(a1)+			; move row 36		move.l		(a0)+,(a1)+			; move row 36		move.l		(a0),(a1)			; move row 36		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 37		move.l		(a0)+,(a1)+			; move row 37		move.l		(a0)+,(a1)+			; move row 37		move.l		(a0)+,(a1)+			; move row 37		move.l		(a0),(a1)			; move row 37		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 38		move.l		(a0)+,(a1)+			; move row 38		move.l		(a0)+,(a1)+			; move row 38		move.l		(a0)+,(a1)+			; move row 38		move.l		(a0),(a1)			; move row 38		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 39		move.l		(a0)+,(a1)+			; move row 39		move.l		(a0)+,(a1)+			; move row 39		move.l		(a0)+,(a1)+			; move row 39		move.l		(a0),(a1)			; move row 39		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 40		move.l		(a0)+,(a1)+			; move row 40		move.l		(a0)+,(a1)+			; move row 40		move.l		(a0)+,(a1)+			; move row 40		move.l		(a0),(a1)			; move row 40		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 41		move.l		(a0)+,(a1)+			; move row 41		move.l		(a0)+,(a1)+			; move row 41		move.l		(a0)+,(a1)+			; move row 41		move.l		(a0),(a1)			; move row 41		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 42		move.l		(a0)+,(a1)+			; move row 42		move.l		(a0)+,(a1)+			; move row 42		move.l		(a0)+,(a1)+			; move row 42		move.l		(a0),(a1)			; move row 42		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 43		move.l		(a0)+,(a1)+			; move row 43		move.l		(a0)+,(a1)+			; move row 43		move.l		(a0)+,(a1)+			; move row 43		move.l		(a0),(a1)			; move row 43		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 44		move.l		(a0)+,(a1)+			; move row 44		move.l		(a0)+,(a1)+			; move row 44		move.l		(a0)+,(a1)+			; move row 44		move.l		(a0),(a1)			; move row 44	}}/*========================================================  DumpWholeBallAsm4  */void DumpWholeBallAsm4 (long src, long dest){	asm 68000	{		move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address										; 0 = source   1 = dest		move.w		workRowBytes, d0	; next row offset		move.w		screenRowBytes, d1	; next row offset		subq.w		#8, d0				; compensate for (a0)+ inc. (4 x +'s)		subq.w		#8, d1				; compensate for (a1)+ increment		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0),(a1)			; move row 12	}}/*========================================================  DumpCursorAsm4  */void DumpCursorAsm4 (long src, long dest){	asm 68000	{		move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address										; 0 = source   1 = dest		move.w		workRowBytes, d0	; next row offset		move.w		screenRowBytes, d1	; next row offset		subq.w		#8, d0				; compensate for (a0)+ inc. (4 x +'s)		subq.w		#8, d1				; compensate for (a1)+ increment		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0),(a1)			; move row 8	}}/*========================================================  DumpDoorToScreenAsm4  */void DumpDoorToScreenAsm4 (void){	long			srcAddress, destAddress;	srcAddress = theDoor.workDestAddr[theDoor.doorOpen];	destAddress = theDoor.screenDestAddr[theDoor.doorOpen];		asm 68000	{		move.l		srcAddress, a0		; src bitmap address		move.l		destAddress, a1		; dest screen address										; 0 = source   1 = dest		move.w		workRowBytes, d0	; next row offset		move.w		screenRowBytes, d1	; next row offset		subi.w		#12, d0				; compensate for (a0)+ increment		subi.w		#12, d1				; compensate for (a1)+ increment		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0),(a1)			; move row 12		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0),(a1)			; move row 13		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0),(a1)			; move row 14		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0),(a1)			; move row 15		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0),(a1)			; move row 16		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0),(a1)			; move row 17		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0),(a1)			; move row 18		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0),(a1)			; move row 19		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0),(a1)			; move row 20		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0),(a1)			; move row 21	}}/*========================================================  PatchPlayerAsm4  */void PatchPlayerAsm4 (long src, long dest){	asm 68000	{		move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address										; 0 = source   1 = dest		move.w		backRowBytes, d0	; next row offset		move.w		workRowBytes, d1	; next row offset		subi.w		#16, d0				; compensate for (a0)+ inc. (4 x +'s)		subi.w		#16, d1				; compensate for (a1)+ increment		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.w		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.w		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.w		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.w		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.w		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.w		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.w		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.w		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.w		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.w		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.w		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.w		(a0),(a1)			; move row 12		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0)+,(a1)+			; move row 13		move.l		(a0)+,(a1)+			; move row 13		move.w		(a0),(a1)			; move row 13		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0)+,(a1)+			; move row 14		move.l		(a0)+,(a1)+			; move row 14		move.w		(a0),(a1)			; move row 14		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0)+,(a1)+			; move row 15		move.l		(a0)+,(a1)+			; move row 15		move.w		(a0),(a1)			; move row 15		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0)+,(a1)+			; move row 16		move.l		(a0)+,(a1)+			; move row 16		move.w		(a0),(a1)			; move row 16		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0)+,(a1)+			; move row 17		move.l		(a0)+,(a1)+			; move row 17		move.w		(a0),(a1)			; move row 17		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0)+,(a1)+			; move row 18		move.l		(a0)+,(a1)+			; move row 18		move.w		(a0),(a1)			; move row 18		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0)+,(a1)+			; move row 19		move.l		(a0)+,(a1)+			; move row 19		move.w		(a0),(a1)			; move row 19		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0)+,(a1)+			; move row 20		move.l		(a0)+,(a1)+			; move row 20		move.w		(a0),(a1)			; move row 20		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0)+,(a1)+			; move row 21		move.l		(a0)+,(a1)+			; move row 21		move.w		(a0),(a1)			; move row 21		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 22		move.l		(a0)+,(a1)+			; move row 22		move.l		(a0)+,(a1)+			; move row 22		move.l		(a0)+,(a1)+			; move row 22		move.w		(a0),(a1)			; move row 22		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 23		move.l		(a0)+,(a1)+			; move row 23		move.l		(a0)+,(a1)+			; move row 23		move.l		(a0)+,(a1)+			; move row 23		move.w		(a0),(a1)			; move row 23		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 24		move.l		(a0)+,(a1)+			; move row 24		move.l		(a0)+,(a1)+			; move row 24		move.l		(a0)+,(a1)+			; move row 24		move.w		(a0),(a1)			; move row 24		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 25		move.l		(a0)+,(a1)+			; move row 25		move.l		(a0)+,(a1)+			; move row 25		move.l		(a0)+,(a1)+			; move row 25		move.w		(a0),(a1)			; move row 25		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 26		move.l		(a0)+,(a1)+			; move row 26		move.l		(a0)+,(a1)+			; move row 26		move.l		(a0)+,(a1)+			; move row 26		move.w		(a0),(a1)			; move row 26		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 27		move.l		(a0)+,(a1)+			; move row 27		move.l		(a0)+,(a1)+			; move row 27		move.l		(a0)+,(a1)+			; move row 27		move.w		(a0),(a1)			; move row 27		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 28		move.l		(a0)+,(a1)+			; move row 28		move.l		(a0)+,(a1)+			; move row 28		move.l		(a0)+,(a1)+			; move row 28		move.w		(a0),(a1)			; move row 28		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 29		move.l		(a0)+,(a1)+			; move row 29		move.l		(a0)+,(a1)+			; move row 29		move.l		(a0)+,(a1)+			; move row 29		move.w		(a0),(a1)			; move row 29		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 30		move.l		(a0)+,(a1)+			; move row 30		move.l		(a0)+,(a1)+			; move row 30		move.l		(a0)+,(a1)+			; move row 30		move.w		(a0),(a1)			; move row 30		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 31		move.l		(a0)+,(a1)+			; move row 31		move.l		(a0)+,(a1)+			; move row 31		move.l		(a0)+,(a1)+			; move row 31		move.w		(a0),(a1)			; move row 31		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 32		move.l		(a0)+,(a1)+			; move row 32		move.l		(a0)+,(a1)+			; move row 32		move.l		(a0)+,(a1)+			; move row 32		move.w		(a0),(a1)			; move row 32		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 33		move.l		(a0)+,(a1)+			; move row 33		move.l		(a0)+,(a1)+			; move row 33		move.l		(a0)+,(a1)+			; move row 33		move.w		(a0),(a1)			; move row 33		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 34		move.l		(a0)+,(a1)+			; move row 34		move.l		(a0)+,(a1)+			; move row 34		move.l		(a0)+,(a1)+			; move row 34		move.w		(a0),(a1)			; move row 34		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 35		move.l		(a0)+,(a1)+			; move row 35		move.l		(a0)+,(a1)+			; move row 35		move.l		(a0)+,(a1)+			; move row 35		move.w		(a0),(a1)			; move row 35		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 36		move.l		(a0)+,(a1)+			; move row 36		move.l		(a0)+,(a1)+			; move row 36		move.l		(a0)+,(a1)+			; move row 36		move.w		(a0),(a1)			; move row 36		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 37		move.l		(a0)+,(a1)+			; move row 37		move.l		(a0)+,(a1)+			; move row 37		move.l		(a0)+,(a1)+			; move row 37		move.w		(a0),(a1)			; move row 37		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 38		move.l		(a0)+,(a1)+			; move row 38		move.l		(a0)+,(a1)+			; move row 38		move.l		(a0)+,(a1)+			; move row 38		move.w		(a0),(a1)			; move row 38		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 39		move.l		(a0)+,(a1)+			; move row 39		move.l		(a0)+,(a1)+			; move row 39		move.l		(a0)+,(a1)+			; move row 39		move.w		(a0),(a1)			; move row 39		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 40		move.l		(a0)+,(a1)+			; move row 40		move.l		(a0)+,(a1)+			; move row 40		move.l		(a0)+,(a1)+			; move row 40		move.w		(a0),(a1)			; move row 40		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 41		move.l		(a0)+,(a1)+			; move row 41		move.l		(a0)+,(a1)+			; move row 41		move.l		(a0)+,(a1)+			; move row 41		move.w		(a0),(a1)			; move row 41		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 42		move.l		(a0)+,(a1)+			; move row 42		move.l		(a0)+,(a1)+			; move row 42		move.l		(a0)+,(a1)+			; move row 42		move.w		(a0),(a1)			; move row 42		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 43		move.l		(a0)+,(a1)+			; move row 43		move.l		(a0)+,(a1)+			; move row 43		move.l		(a0)+,(a1)+			; move row 43		move.w		(a0),(a1)			; move row 43		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 44		move.l		(a0)+,(a1)+			; move row 44		move.l		(a0)+,(a1)+			; move row 44		move.l		(a0)+,(a1)+			; move row 44		move.w		(a0),(a1)			; move row 44	}}/*========================================================  PatchBallAsm4  */void PatchBallAsm4 (long src, long dest){	asm 68000	{		move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address										; 0 = source   1 = dest		move.w		backRowBytes, d0	; next row offset		move.w		workRowBytes, d1	; next row offset		subq.w		#8, d0				; compensate for (a0)+ inc. (4 x +'s)		subq.w		#8, d1				; compensate for (a1)+ increment		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.w		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.w		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.w		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.w		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.w		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.w		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.w		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.w		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 9		move.l		(a0)+,(a1)+			; move row 9		move.w		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 10		move.l		(a0)+,(a1)+			; move row 10		move.w		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 11		move.l		(a0)+,(a1)+			; move row 11		move.w		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 12		move.l		(a0)+,(a1)+			; move row 12		move.w		(a0),(a1)			; move row 12	}}/*========================================================  PatchCursorAsm4  */void PatchCursorAsm4 (long src, long dest){	asm 68000	{		move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address										; 0 = source   1 = dest		move.w		backRowBytes, d0	; next row offset		move.w		workRowBytes, d1	; next row offset		subq.w		#8, d0				; compensate for (a0)+ inc. (4 x +'s)		subq.w		#8, d1				; compensate for (a1)+ increment		move.l		(a0)+,(a1)+			; move row 1		move.l		(a0)+,(a1)+			; move row 1		move.w		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 2		move.l		(a0)+,(a1)+			; move row 2		move.w		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 3		move.l		(a0)+,(a1)+			; move row 3		move.w		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 4		move.l		(a0)+,(a1)+			; move row 4		move.w		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 5		move.l		(a0)+,(a1)+			; move row 5		move.w		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 6		move.l		(a0)+,(a1)+			; move row 6		move.w		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 7		move.l		(a0)+,(a1)+			; move row 7		move.w		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 8		move.l		(a0)+,(a1)+			; move row 8		move.w		(a0),(a1)			; move row 8	}}/*========================================================  RenderSceneAsm4  */void RenderSceneAsm4 (void){	long			srcAddress, destAddress;	long			ballOffIs, playerOffIs, opponentOffIs, cursorOffIs;	Point			offsetPt;	char			theMode;		ballOffIs = workRowOffsets[theBall.isRect.top] + 			(long)(((short)theBall.isRect.left & 0xFFFC) >> 1);		playerOffIs = workRowOffsets[thePlayer.isRect.top] + 			(long)(((short)thePlayer.isRect.left & 0xFFFC) >> 1);		opponentOffIs = workRowOffsets[theOpponent.isRect.top] + 			(long)(((short)theOpponent.isRect.left & 0xFFFC) >> 1);;		offsetPt.h = 0;	offsetPt.v = 0;	ShieldCursor(&screenRect, offsetPt);		theMode = true32b;	SwapMMUMode(&theMode);		if (theDoor.stateChanged)		DropDoorToWorkMapAsm4();		if ((showBoardCursor) && (!disableBoardCursor) && (drawThisFrame))	{		cursorOffIs = workRowOffsets[boardCursor.isRect.top] + 				(long)(((short)boardCursor.isRect.left & 0xFFFC) >> 1);		destAddress = (long)offWorkPix + cursorOffIs;		MaskBoardCursorAsm4 (destAddress, (boardCursor.isRect.left % 4) * 4);	}		if ((theBall.mode == kBallRolling) && (!theBall.dontDraw) && (drawThisFrame))	{		destAddress = (long)offWorkPix + ballOffIs;		MaskBallAsm4 (destAddress, (theBall.isRect.left % 4) * 4);	}/* mask the bastards to the work map - back to front! */		if (playerInBack)	{		if ((thePlayer.mode != kInStasis) && (drawThisFrame))		{			destAddress = (long)offWorkPix + playerOffIs;			MaskPlayerAsm4(thePlayer.srcAddr, destAddress, thePlayer.maskAddr, 					(thePlayer.isRect.left % 4) * 4);		}		if ((theOpponent.mode != kInStasis) && (drawThisFrame))		{			destAddress = (long)offWorkPix + opponentOffIs;			MaskPlayerAsm4(theOpponent.srcAddr, destAddress, theOpponent.maskAddr, 					(theOpponent.isRect.left % 4) * 4);		}	}	else	{		if ((theOpponent.mode != kInStasis) && (drawThisFrame))		{			destAddress = (long)offWorkPix + opponentOffIs;			MaskPlayerAsm4(theOpponent.srcAddr, destAddress, theOpponent.maskAddr, 					(theOpponent.isRect.left % 4) * 4);		}		if ((thePlayer.mode != kInStasis) && (drawThisFrame))		{			destAddress = (long)offWorkPix + playerOffIs;			MaskPlayerAsm4(thePlayer.srcAddr, destAddress, thePlayer.maskAddr, 					(thePlayer.isRect.left % 4) * 4);		}	}/* blast them to the screen */	if ((thePlayer.mode != kInStasis) && (drawThisFrame))	{		srcAddress = (long)offWorkPix + playerOffIs;		destAddress = screenRowAddrs[thePlayer.isRect.top] + 				(long)(((short)thePlayer.isRect.left & 0xFFFC) >> 1);		DumpWholePlayerAsm4(srcAddress, destAddress);				srcAddress = (long)offWorkPix + workRowOffsets[thePlayer.wasRect.top] + 				(long)(((short)thePlayer.wasRect.left & 0xFFFC) >> 1);		destAddress = screenRowAddrs[thePlayer.wasRect.top] + 				(long)(((short)thePlayer.wasRect.left & 0xFFFC) >> 1);		DumpWholePlayerAsm4(srcAddress, destAddress);	}		if ((theOpponent.mode != kInStasis) && (drawThisFrame))	{		srcAddress = (long)offWorkPix + opponentOffIs;		destAddress = screenRowAddrs[theOpponent.isRect.top] + 				(long)(((short)theOpponent.isRect.left & 0xFFFC) >> 1);		DumpWholePlayerAsm4(srcAddress, destAddress);				srcAddress = (long)offWorkPix + workRowOffsets[theOpponent.wasRect.top] + 				(long)(((short)theOpponent.wasRect.left & 0xFFFC) >> 1);		destAddress = screenRowAddrs[theOpponent.wasRect.top] + 				(long)(((short)theOpponent.wasRect.left & 0xFFFC) >> 1);		DumpWholePlayerAsm4(srcAddress, destAddress);	}	if ((theBall.mode == kBallRolling) && (drawThisFrame))	{		srcAddress = (long)offWorkPix + ballOffIs;		destAddress = screenRowAddrs[theBall.isRect.top] + 				(long)(((short)theBall.isRect.left & 0xFFFC) >> 1);		DumpWholeBallAsm4(srcAddress, destAddress);				srcAddress = (long)offWorkPix + workRowOffsets[theBall.wasRect.top] + 				(long)(((short)theBall.wasRect.left & 0xFFFC) >> 1);		destAddress = screenRowAddrs[theBall.wasRect.top] + 				(long)(((short)theBall.wasRect.left & 0xFFFC) >> 1);		DumpWholeBallAsm4(srcAddress, destAddress);	}	else if (theBall.eraseTheBall)	{		srcAddress = (long)offWorkPix + workRowOffsets[theBall.eraser.top] + 				(long)(((short)theBall.eraser.left & 0xFFFC) >> 1);		destAddress = screenRowAddrs[theBall.eraser.top] + 				(long)(((short)theBall.eraser.left & 0xFFFC) >> 1);		DumpWholeBallAsm4(srcAddress, destAddress);				theBall.eraseTheBall = FALSE;	}		if ((showBoardCursor) && (!disableBoardCursor) && (drawThisFrame))	{		srcAddress = (long)offWorkPix + cursorOffIs;		destAddress = screenRowAddrs[boardCursor.isRect.top] + 				(long)(((short)boardCursor.isRect.left & 0xFFFC) >> 1);		DumpCursorAsm4(srcAddress, destAddress);				srcAddress = (long)offWorkPix + workRowOffsets[boardCursor.wasRect.top] + 				(long)(((short)boardCursor.wasRect.left & 0xFFFC) >> 1);		destAddress = screenRowAddrs[boardCursor.wasRect.top] + 				(long)(((short)boardCursor.wasRect.left & 0xFFFC) >> 1);		DumpCursorAsm4(srcAddress, destAddress);	}		if (theDoor.stateChanged)		DumpDoorToScreenAsm4();/* plug up the holes on the work map */	if ((thePlayer.mode != kInStasis) && (drawThisFrame))	{		srcAddress = (long)offBackPix + playerOffIs;		destAddress = (long)offWorkPix + playerOffIs;		PatchPlayerAsm4(srcAddress, destAddress);	}		if ((theOpponent.mode != kInStasis) && (drawThisFrame))	{		srcAddress = (long)offBackPix + opponentOffIs;		destAddress = (long)offWorkPix + opponentOffIs;		PatchPlayerAsm4(srcAddress, destAddress);	}		if ((theBall.mode == kBallRolling) && (drawThisFrame))	{		srcAddress = (long)offBackPix + ballOffIs;		destAddress = (long)offWorkPix + ballOffIs;		PatchBallAsm4(srcAddress, destAddress);	}		if ((showBoardCursor) && (!disableBoardCursor) && (drawThisFrame))	{		srcAddress = (long)offBackPix + cursorOffIs;		destAddress = (long)offWorkPix + cursorOffIs;		PatchCursorAsm4(srcAddress, destAddress);	}		SwapMMUMode(&theMode);	ShowCursor();}/*========================================================  ReplayWorkToMainAsm4  */void ReplayWorkToMainAsm4 (void){	Point			offsetPt;	char			theMode;		offsetPt.h = 0;	offsetPt.v = 0;	ShieldCursor(&screenRect, offsetPt);		theMode = true32b;	SwapMMUMode(&theMode);		asm 68000	{		move.l		replaySrc, a0		; src bitmap address		move.l		replayDest, a1		; dest screen address										; 0 = source   1 = dest		move.w		workRowBytes, d0	; next row offset		move.w		screenRowBytes, d1	; next row offset		subi.w		#92, d0				; compensate for (a0)+ increment		subi.w		#92, d1				; compensate for (a1)+ increment		move.w		#128, d2			; d2 will count rows	@1	move.l		(a0)+,(a1)+			; move long 1		move.l		(a0)+,(a1)+			; move long 2		move.l		(a0)+,(a1)+			; move long 3		move.l		(a0)+,(a1)+			; move long 4		move.l		(a0)+,(a1)+			; move long 5		move.l		(a0)+,(a1)+			; move long 6		move.l		(a0)+,(a1)+			; move long 7		move.l		(a0)+,(a1)+			; move long 8		move.l		(a0)+,(a1)+			; move long 9		move.l		(a0)+,(a1)+			; move long 10		move.l		(a0)+,(a1)+			; move long 11		move.l		(a0)+,(a1)+			; move long 12		move.l		(a0)+,(a1)+			; move long 13		move.l		(a0)+,(a1)+			; move long 14		move.l		(a0)+,(a1)+			; move long 15		move.l		(a0)+,(a1)+			; move long 16		move.l		(a0)+,(a1)+			; move long 17		move.l		(a0)+,(a1)+			; move long 18		move.l		(a0)+,(a1)+			; move long 19		move.l		(a0)+,(a1)+			; move long 20		move.l		(a0)+,(a1)+			; move long 21		move.l		(a0)+,(a1)+			; move long 22		move.l		(a0)+,(a1)+			; move long 23		move.l		(a0),(a1)			; move long 24		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		subq.w		#1, d2				; decrement row counter		bne			@1					; do another row until d2 = 0	}		SwapMMUMode(&theMode);	ShowCursor();}