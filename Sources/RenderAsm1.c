/*============================================================*//*============================================================*//*==														==*//*==			1-Bit Assembler Rendering Routines			==*//*==														==*//*============================================================*//*============================================================*//*========================================================  Includes  */#include "Globals.h"#include "UnivUtilities.h"#include "RenderAsm1.h"/*========================================================  Functions  *//*========================================================  DropDoorToWorkMapAsm1  */void DropDoorToWorkMapAsm1 (void){	long			srcAddress, destAddress;	srcAddress = theDoor.srcAddrs[theDoor.doorOpen][theDoor.doorState];	destAddress = theDoor.workDestAddr[theDoor.doorOpen];		asm 68000	{		move.l		srcAddress, a0		; src bitmap address		move.l		destAddress, a1		; dest screen address										; 0 = source   1 = dest		move.w		partsRowBytes, d0	; next row offset		move.w		workRowBytes, d1	; next row offset				move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 12		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 13		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 14		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 15		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 16		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 17		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 18		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 19		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 20		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 21	}		destAddress = theDoor.backDestAddr[theDoor.doorOpen];		asm 68000	{		move.l		srcAddress, a0		; src bitmap address		move.l		destAddress, a1		; dest screen address										; 0 = source   1 = dest		move.w		partsRowBytes, d0	; next row offset		move.w		workRowBytes, d1	; next row offset				move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 12		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 13		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 14		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 15		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 16		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 17		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 18		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 19		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 20		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 21	}}/*========================================================  MaskCursorAsm1  */void MaskCursorAsm1 (long dest, short shiftRight){	asm 68000	{		move.l		a2, -(sp)			; save a2 on stack		move.l		d3, -(sp)			; save d3 on stack		move.l		d4, -(sp)			; save d4 on stack		move.l		d5, -(sp)			; save d5 on stack		move.l		d6, -(sp)			; save d6 on stack				move.l		boardCursor.srcAddr, a0		; src bitmap address		move.l		dest, a1					; dest screen address		move.l		boardCursor.maskAddr, a2	; mask bitmap address				move.w		partsRowBytes, d0	; next row offset (parts)		move.w		maskRowBytes, d6	; next row offset (mask)		move.w		workRowBytes, d1	; next row offset		move.w		shiftRight, d2		; d2 will hold # of bits to shift right				move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest				move.l		(sp)+, d6			; restore d6 from stack		move.l		(sp)+, d5			; restore d5 from stack		move.l		(sp)+, d4			; restore d4 from stack		move.l		(sp)+, d3			; restore d3 from stack		move.l		(sp)+, a2			; restore a2 from stack	}}/*========================================================  MaskBallAsm1  */void MaskBallAsm1 (long dest, short shiftRight){	asm 68000	{		move.l		a2, -(sp)			; save a2 on stack		move.l		d3, -(sp)			; save d3 on stack		move.l		d4, -(sp)			; save d4 on stack		move.l		d5, -(sp)			; save d5 on stack		move.l		d6, -(sp)			; save d6 on stack				move.l		ballSrcAddr, a0		; src bitmap address		move.l		dest, a1			; dest screen address		move.l		ballMaskAddr, a2	; mask bitmap address				move.w		partsRowBytes, d0	; next row offset (parts)		move.w		workRowBytes, d1	; next row offset		move.w		maskRowBytes, d6	; next row offset (mask)		move.w		shiftRight, d2		; d2 will hold # of bits to shift right				move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d6, a2				; add row offset to mask		move.l		(a2), d4			; move mask row 1		lsr.l		d2, d4				; shift d4 logically d2 bits to the right		move.l		(a0), d5			; move src row 1		lsr.l		d2, d5				; shift d5 logically d2 bits to the right		and.l		d4, d5				; clear trash bits		not.l		d4					; invert mask		and.l		d4, (a1)			; and mask to dest		or.l		d5, (a1)			; or src to dest				move.l		(sp)+, d6			; restore d6 from stack		move.l		(sp)+, d5			; restore d5 from stack		move.l		(sp)+, d4			; restore d4 from stack		move.l		(sp)+, d3			; restore d3 from stack		move.l		(sp)+, a2			; restore a2 from stack	}}/*========================================================  MaskPlayerAsm1  */void MaskPlayerAsm1 (long src, long dest, long mask, short shiftRight){	asm 68000	{		move.l		a2, -(sp)			; save a2 on stack		move.l		d3, -(sp)			; save d3 on stack		move.l		d4, -(sp)			; save d4 on stack		move.l		d5, -(sp)			; save d5 on stack		move.l		d6, -(sp)			; save d6 on stack		move.l		d7, -(sp)			; save d7 on stack				move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address		move.l		mask, a2			; mask bitmap address				move.w		partsRowBytes, d0	; next row offset (parts)		move.w		workRowBytes, d1	; next row offset		move.w		shiftRight, d2		; d2 will hold # of bits to shift right		move.w		#32, d3				; copy shiftRight to d3		sub.w		d2, d3				; calculate value to shift left in d3				move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		adda.w		d0, a2				; add row offset to mask		suba.w		#10, a2				; compensate for mask/parts difference		move.l		(a2), d4			; move mask row 1		move.l		d4, d5				; copy the mask to d5		lsr.l		d2, d4				; shift d4 bits to the right		lsl.l		d3, d5				; shift d5 bits to the left		move.l		(a0), d6			; move src row 1		move.l		d6, d7				; copy the src to d7		lsr.l		d2, d6				; shift d6 bits to the right		lsl.l		d3, d7				; shift d7 bits to the left		and.l		d4, d6				; clean out unwanted bits		and.l		d5, d7				; clean out unwanted bits		not.l		d4					; invert mask		not.l		d5					; invert mask		and.l		d4, (a1)			; and mask to dest		and.l		d5, 4(a1)			; and mask to dest		or.l		d6, (a1)			; or src to dest		or.l		d7, 4(a1)			; or src to dest				move.l		(sp)+, d7			; restore d7 from stack		move.l		(sp)+, d6			; restore d6 from stack		move.l		(sp)+, d5			; restore d5 from stack		move.l		(sp)+, d4			; restore d4 from stack		move.l		(sp)+, d3			; restore d3 from stack		move.l		(sp)+, a2			; restore a2 from stack	}}/*========================================================  DumpWholePlayerAsm1  */void DumpWholePlayerAsm1 (long src, long dest){	asm 68000	{		move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address										; 0 = source   1 = dest		move.w		workRowBytes, d0	; next row offset		move.w		screenRowBytes, d1	; next row offset		subq.w		#4, d0				; compensate for (a0)+ inc. (4 x +'s)		subq.w		#4, d1				; compensate for (a1)+ increment		move.l		(a0)+,(a1)+			; move row 1		move.w		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 2		move.w		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 3		move.w		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 4		move.w		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 5		move.w		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 6		move.w		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 7		move.w		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 8		move.w		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 9		move.w		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 10		move.w		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 11		move.w		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 12		move.w		(a0),(a1)			; move row 12		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 13		move.w		(a0),(a1)			; move row 13		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 14		move.w		(a0),(a1)			; move row 14		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 15		move.w		(a0),(a1)			; move row 15		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 16		move.w		(a0),(a1)			; move row 16		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 17		move.w		(a0),(a1)			; move row 17		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 18		move.w		(a0),(a1)			; move row 18		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 19		move.w		(a0),(a1)			; move row 19		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 20		move.w		(a0),(a1)			; move row 20		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 21		move.w		(a0),(a1)			; move row 21		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 22		move.w		(a0),(a1)			; move row 22		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 23		move.w		(a0),(a1)			; move row 23		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 24		move.w		(a0),(a1)			; move row 24		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 25		move.w		(a0),(a1)			; move row 25		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 26		move.w		(a0),(a1)			; move row 26		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 27		move.w		(a0),(a1)			; move row 27		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 28		move.w		(a0),(a1)			; move row 28		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 29		move.w		(a0),(a1)			; move row 29		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 30		move.w		(a0),(a1)			; move row 30		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 31		move.w		(a0),(a1)			; move row 31		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 32		move.w		(a0),(a1)			; move row 32		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 33		move.w		(a0),(a1)			; move row 33		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 34		move.w		(a0),(a1)			; move row 34		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 35		move.w		(a0),(a1)			; move row 35		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 36		move.w		(a0),(a1)			; move row 36		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 37		move.w		(a0),(a1)			; move row 37		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 38		move.w		(a0),(a1)			; move row 38		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 39		move.w		(a0),(a1)			; move row 39		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 40		move.w		(a0),(a1)			; move row 40		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 41		move.w		(a0),(a1)			; move row 41		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 42		move.w		(a0),(a1)			; move row 42		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 43		move.w		(a0),(a1)			; move row 43		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 44		move.w		(a0),(a1)			; move row 44			}}/*========================================================  DumpWholeBallAsm1  */void DumpWholeBallAsm1 (long src, long dest){	asm 68000	{		move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address										; 0 = source   1 = dest		move.w		workRowBytes, d0	; next row offset		move.w		screenRowBytes, d1	; next row offset		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 1	}}/*========================================================  DumpCursorAsm1  */void DumpCursorAsm1 (long src, long dest){	asm 68000	{		move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address										; 0 = source   1 = dest		move.w		workRowBytes, d0	; next row offset		move.w		screenRowBytes, d1	; next row offset		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 8	}}/*========================================================  DumpDoorToScreenAsm1  */void DumpDoorToScreenAsm1 (void){	long			srcAddress, destAddress;	srcAddress = theDoor.workDestAddr[theDoor.doorOpen];	destAddress = theDoor.screenDestAddr[theDoor.doorOpen];		asm 68000	{		move.l		srcAddress, a0		; src bitmap address		move.l		destAddress, a1		; dest screen address										; 0 = source   1 = dest		move.w		workRowBytes, d0	; next row offset		move.w		screenRowBytes, d1	; next row offset				move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 12		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 13		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 14		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 15		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 16		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 17		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 18		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 19		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 20		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 21	}}/*========================================================  PatchPlayerAsm1  */void PatchPlayerAsm1 (long src, long dest){	asm 68000	{		move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address										; 0 = source   1 = dest		move.w		backRowBytes, d0	; next row offset		move.w		workRowBytes, d1	; next row offset		subq.w		#4, d0				; compensate for (a0)+ inc. (4 x +'s)		subq.w		#4, d1				; compensate for (a1)+ increment		move.l		(a0)+,(a1)+			; move row 1		move.w		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 2		move.w		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 3		move.w		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 4		move.w		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 5		move.w		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 6		move.w		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 7		move.w		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 8		move.w		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 9		move.w		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 10		move.w		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 11		move.w		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 12		move.w		(a0),(a1)			; move row 12		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 13		move.w		(a0),(a1)			; move row 13		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 14		move.w		(a0),(a1)			; move row 14		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 15		move.w		(a0),(a1)			; move row 15		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 16		move.w		(a0),(a1)			; move row 16		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 17		move.w		(a0),(a1)			; move row 17		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 18		move.w		(a0),(a1)			; move row 18		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 19		move.w		(a0),(a1)			; move row 19		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 20		move.w		(a0),(a1)			; move row 20		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 21		move.w		(a0),(a1)			; move row 21		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 22		move.w		(a0),(a1)			; move row 22		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 23		move.w		(a0),(a1)			; move row 23		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 24		move.w		(a0),(a1)			; move row 24		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 25		move.w		(a0),(a1)			; move row 25		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 26		move.w		(a0),(a1)			; move row 26		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 27		move.w		(a0),(a1)			; move row 27		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 28		move.w		(a0),(a1)			; move row 28		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 29		move.w		(a0),(a1)			; move row 29		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 30		move.w		(a0),(a1)			; move row 30		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 31		move.w		(a0),(a1)			; move row 31		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 32		move.w		(a0),(a1)			; move row 32		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 33		move.w		(a0),(a1)			; move row 33		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 34		move.w		(a0),(a1)			; move row 34		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 35		move.w		(a0),(a1)			; move row 35		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 36		move.w		(a0),(a1)			; move row 36		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 37		move.w		(a0),(a1)			; move row 37		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 38		move.w		(a0),(a1)			; move row 38		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 39		move.w		(a0),(a1)			; move row 39		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 40		move.w		(a0),(a1)			; move row 40		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 41		move.w		(a0),(a1)			; move row 41		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 42		move.w		(a0),(a1)			; move row 42		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 43		move.w		(a0),(a1)			; move row 43		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0)+,(a1)+			; move row 44		move.w		(a0),(a1)			; move row 44	}}/*========================================================  PatchBallAsm1  */void PatchBallAsm1 (long src, long dest){	asm 68000	{		move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address										; 0 = source   1 = dest		move.w		backRowBytes, d0	; next row offset		move.w		workRowBytes, d1	; next row offset		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 8		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 9		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 10		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 11		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 12	}}	/*========================================================  PatchCursorAsm1  */void PatchCursorAsm1 (long src, long dest){	asm 68000	{		move.l		src, a0				; src bitmap address		move.l		dest, a1			; dest screen address										; 0 = source   1 = dest		move.w		backRowBytes, d0	; next row offset		move.w		workRowBytes, d1	; next row offset		move.l		(a0),(a1)			; move row 1		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 2		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 3		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 4		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 5		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 7		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		move.l		(a0),(a1)			; move row 8	}}	/*========================================================  RenderSceneAsm1  */void RenderSceneAsm1 (void){	long			srcAddress, destAddress;	long			ballOffIs, playerOffIs, opponentOffIs, cursorOffIs;	Point			offsetPt;	char			theMode;		ballOffIs = workRowOffsets[theBall.isRect.top] + 			(long)(((short)theBall.isRect.left & 0xFFF0) >> 3);		playerOffIs = workRowOffsets[thePlayer.isRect.top] + 			(long)(((short)thePlayer.isRect.left & 0xFFF0) >> 3);		opponentOffIs = workRowOffsets[theOpponent.isRect.top] + 			(long)(((short)theOpponent.isRect.left & 0xFFF0) >> 3);		offsetPt.h = 0;	offsetPt.v = 0;	ShieldCursor(&screenRect, offsetPt);			if (knowsColor)	{		theMode = true32b;		SwapMMUMode(&theMode);	}	/* dick with the door */	if (theDoor.stateChanged)		DropDoorToWorkMapAsm1();		if ((showBoardCursor) && (!disableBoardCursor) && (drawThisFrame))	{		cursorOffIs = workRowOffsets[boardCursor.isRect.top] + 				(long)(((short)boardCursor.isRect.left & 0xFFF0) >> 3);		destAddress = (long)offWorkBits.baseAddr + cursorOffIs;		MaskCursorAsm1 (destAddress, boardCursor.isRect.left & 0x000F);	}		if ((theBall.mode == kBallRolling) && (!theBall.dontDraw) && (drawThisFrame))	{		destAddress = (long)offWorkBits.baseAddr + ballOffIs;		MaskBallAsm1 (destAddress, theBall.isRect.left & 0x000F);	}	/* mask the bastards to the work map - back to front! */	if (playerInBack)	{		if ((thePlayer.mode != kInStasis) && (drawThisFrame))		{			destAddress = (long)offWorkBits.baseAddr + playerOffIs;			MaskPlayerAsm1(thePlayer.srcAddr, destAddress, thePlayer.maskAddr, 					thePlayer.isRect.left & 0x000F);		}		if ((theOpponent.mode != kInStasis) && (drawThisFrame))		{			destAddress = (long)offWorkBits.baseAddr + opponentOffIs;			MaskPlayerAsm1(theOpponent.srcAddr, destAddress, theOpponent.maskAddr, 					theOpponent.isRect.left & 0x000F);		}	}	else	{		if ((theOpponent.mode != kInStasis) && (drawThisFrame))		{			destAddress = (long)offWorkBits.baseAddr + opponentOffIs;			MaskPlayerAsm1(theOpponent.srcAddr, destAddress, theOpponent.maskAddr, 					theOpponent.isRect.left & 0x000F);		}		if ((thePlayer.mode != kInStasis) && (drawThisFrame))		{			destAddress = (long)offWorkBits.baseAddr + playerOffIs;			MaskPlayerAsm1(thePlayer.srcAddr, destAddress, thePlayer.maskAddr, 					thePlayer.isRect.left & 0x000F);		}	}/* blast them to the screen */	if ((thePlayer.mode != kInStasis) && (drawThisFrame))	{		srcAddress = (long)offWorkBits.baseAddr + playerOffIs;		destAddress = screenRowAddrs[thePlayer.isRect.top] + 				(long)(((short)thePlayer.isRect.left & 0xFFF0) >> 3);		DumpWholePlayerAsm1(srcAddress, destAddress);				srcAddress = (long)offWorkBits.baseAddr + workRowOffsets[thePlayer.wasRect.top] + 				(long)(((short)thePlayer.wasRect.left & 0xFFF0) >> 3);		destAddress = screenRowAddrs[thePlayer.wasRect.top] + 				(long)(((short)thePlayer.wasRect.left & 0xFFF0) >> 3);		DumpWholePlayerAsm1(srcAddress, destAddress);	}	if ((theOpponent.mode != kInStasis) && (drawThisFrame))	{		srcAddress = (long)offWorkBits.baseAddr + opponentOffIs;		destAddress = screenRowAddrs[theOpponent.isRect.top] + 				(long)(((short)theOpponent.isRect.left & 0xFFF0) >> 3);		DumpWholePlayerAsm1(srcAddress, destAddress);				srcAddress = (long)offWorkBits.baseAddr + workRowOffsets[theOpponent.wasRect.top] + 				(long)(((short)theOpponent.wasRect.left & 0xFFF0) >> 3);		destAddress = screenRowAddrs[theOpponent.wasRect.top] + 				(long)(((short)theOpponent.wasRect.left & 0xFFF0) >> 3);		DumpWholePlayerAsm1(srcAddress, destAddress);	}	if ((theBall.mode == kBallRolling) && (drawThisFrame))	{		srcAddress = (long)offWorkBits.baseAddr + ballOffIs;		destAddress = screenRowAddrs[theBall.isRect.top] + 				(long)(((short)theBall.isRect.left & 0xFFF0) >> 3);		DumpWholeBallAsm1(srcAddress, destAddress);				srcAddress = (long)offWorkBits.baseAddr + workRowOffsets[theBall.wasRect.top] + 				(long)(((short)theBall.wasRect.left & 0xFFF0) >> 3);		destAddress = screenRowAddrs[theBall.wasRect.top] + 				(long)(((short)theBall.wasRect.left & 0xFFF0) >> 3);		DumpWholeBallAsm1(srcAddress, destAddress);	}	else if (theBall.eraseTheBall)	{		srcAddress = (long)offWorkBits.baseAddr + workRowOffsets[theBall.eraser.top] + 				(long)(((short)theBall.eraser.left & 0xFFF0) >> 3);		destAddress = screenRowAddrs[theBall.eraser.top] + 				(long)(((short)theBall.eraser.left & 0xFFF0) >> 3);		DumpWholeBallAsm1(srcAddress, destAddress);				theBall.eraseTheBall = FALSE;	}	if ((showBoardCursor) && (!disableBoardCursor) && (drawThisFrame))	{		srcAddress = (long)offWorkBits.baseAddr + cursorOffIs;		destAddress = screenRowAddrs[boardCursor.isRect.top] + 				(long)(((short)boardCursor.isRect.left & 0xFFF0) >> 3);		DumpCursorAsm1(srcAddress, destAddress);				srcAddress = (long)offWorkBits.baseAddr + workRowOffsets[boardCursor.wasRect.top] + 				(long)(((short)boardCursor.wasRect.left & 0xFFF0) >> 3);		destAddress = screenRowAddrs[boardCursor.wasRect.top] + 				(long)(((short)boardCursor.wasRect.left & 0xFFF0) >> 3);		DumpCursorAsm1(srcAddress, destAddress);	}	if (theDoor.stateChanged)		DumpDoorToScreenAsm1();/* plug up the holes on the work map */	if ((thePlayer.mode != kInStasis) && (drawThisFrame))	{		srcAddress = (long)offBackBits.baseAddr + playerOffIs;		destAddress = (long)offWorkBits.baseAddr + playerOffIs;		PatchPlayerAsm1(srcAddress, destAddress);	}	if ((theOpponent.mode != kInStasis) && (drawThisFrame))	{		srcAddress = (long)offBackBits.baseAddr + opponentOffIs;		destAddress = (long)offWorkBits.baseAddr + opponentOffIs;		PatchPlayerAsm1(srcAddress, destAddress);	}	if ((theBall.mode == kBallRolling) && (drawThisFrame))	{		srcAddress = (long)offBackBits.baseAddr + ballOffIs;		destAddress = (long)offWorkBits.baseAddr + ballOffIs;		PatchBallAsm1(srcAddress, destAddress);	}	if ((showBoardCursor) && (!disableBoardCursor) && (drawThisFrame))	{		srcAddress = (long)offBackBits.baseAddr + cursorOffIs;		destAddress = (long)offWorkBits.baseAddr + cursorOffIs;		PatchCursorAsm1(srcAddress, destAddress);	}		if (knowsColor)		SwapMMUMode(&theMode);		ShowCursor();}/*========================================================  ReplayWorkToMainAsm1  */void ReplayWorkToMainAsm1 (void){	Point			offsetPt;	char			theMode;		offsetPt.h = 0;	offsetPt.v = 0;	ShieldCursor(&screenRect, offsetPt);		if (knowsColor)	{		theMode = true32b;		SwapMMUMode(&theMode);	}		asm 68000	{		move.l		replaySrc, a0		; src bitmap address		move.l		replayDest, a1		; dest screen address										; 0 = source   1 = dest		move.w		workRowBytes, d0	; next row offset		move.w		screenRowBytes, d1	; next row offset		subi.w		#20, d0				; compensate for (a0)+ increment		subi.w		#20, d1				; compensate for (a1)+ increment		move.w		#128, d2			; d2 will count rows	@1	move.l		(a0)+,(a1)+			; move long 1		move.l		(a0)+,(a1)+			; move long 2		move.l		(a0)+,(a1)+			; move long 3		move.l		(a0)+,(a1)+			; move long 4		move.l		(a0)+,(a1)+			; move long 5		move.l		(a0),(a1)			; move long 6		adda.w		d0, a0				; add row offset to src		adda.w		d1, a1				; add row offset to dest		subq.w		#1, d2				; decrement row counter		bne			@1					; do another row until d2 = 0	}		if (knowsColor)		SwapMMUMode(&theMode);		ShowCursor();}