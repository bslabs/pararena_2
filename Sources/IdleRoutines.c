/*============================================================*//*============================================================*//*==														==*//*==				Idle Support Routines					==*//*==														==*//*==			(routines called from idle.c)				==*//*==														==*//*============================================================*//*============================================================*//*========================================================  Includes  */#include "Globals.h"#include "UnivUtilities.h"#include "SMS.h"#include "IdleRoutines.h"#include "SoundUtils.h"#include "PlayerStats.h"#include "ValidInstall.h"/*========================================================  Functions  *//*========================================================  DrawOpenHand  */void DrawOpenHand (void){	Rect		srcRect, destRect;		SetRect(&srcRect, 16, 227, 29, 236);	SetRect(&destRect, 0, 0, 13, 9);	OffsetRect(&destRect, replayRect.left + 74, replayRect.top + 55);		if (isColor)		CopyBits(&((GrafPtr)offCPartsPtr)->portBits, &(((GrafPtr)mainWndo)->portBits), 				&srcRect, &destRect, srcCopy, nil);	else		CopyBits(&offPartsBits, &(mainWndo->portBits), &srcRect, &destRect, 				srcCopy, nil);}/*========================================================  DrawClosedHand  */void DrawClosedHand (void){	Rect		srcRect, destRect;		SetRect(&srcRect, 0, 227, 13, 236);	SetRect(&destRect, 0, 0, 13, 9);	OffsetRect(&destRect, replayRect.left + 74, replayRect.top + 55);		if (isColor)		CopyBits(&((GrafPtr)offCPartsPtr)->portBits, &(((GrafPtr)mainWndo)->portBits), 				&srcRect, &destRect, srcCopy, nil);	else		CopyBits(&offPartsBits, &(mainWndo->portBits), &srcRect, &destRect, 				srcCopy, nil);}/*========================================================  DrawOpenMouth  */void DrawOpenMouth (short waitFor){	Rect		srcRect, destRect;	long		dummyLong;		SetRect(&srcRect, 16, 222, 25, 227);	SetRect(&destRect, 0, 0, 9, 5);	OffsetRect(&destRect, replayRect.left + 152, replayRect.top + 49);		if (isColor)		CopyBits(&((GrafPtr)offCPartsPtr)->portBits, &(((GrafPtr)mainWndo)->portBits), 				&srcRect, &destRect, srcCopy, nil);	else		CopyBits(&offPartsBits, &(mainWndo->portBits), &srcRect, &destRect, 				srcCopy, nil);		Delay(waitFor, &dummyLong);}/*========================================================  DrawClosedMouth  */void DrawClosedMouth (short waitFor){	Rect		srcRect, destRect;	long		dummyLong;		SetRect(&srcRect, 0, 222, 9, 227);	SetRect(&destRect, 0, 0, 9, 5);	OffsetRect(&destRect, replayRect.left + 152, replayRect.top + 49);		if (isColor)		CopyBits(&((GrafPtr)offCPartsPtr)->portBits, &(((GrafPtr)mainWndo)->portBits), 				&srcRect, &destRect, srcCopy, nil);	else		CopyBits(&offPartsBits, &(mainWndo->portBits), &srcRect, &destRect, 				srcCopy, nil);		Delay(waitFor, &dummyLong);}/*========================================================  DoOpeningAnnouncer  */void DoOpeningAnnouncer (void){	Rect		tempRect;	GrafPtr		wasPort;	PicHandle	thePict;	Handle		theSound;	long		dummyLong;	short		i;		if (soundFileRefNum == -1)		return;		tempRect = replayRect;	InsetRect(&tempRect, 63, 63);		GetPort((GrafPtr *)&wasPort);		if (isColor)	{		SetPort((GrafPtr)offCWorkPtr);		thePict = GetPicture(kAnnouncerPict4ID);	}	else	{		SetPort((GrafPtr)offWorkPtr);		thePict = GetPicture(kAnnouncerPict1ID);	}	if (thePict == kNilPointer)		return;		DrawPicture(thePict, &replayRect);	ReleaseResource((Handle)thePict);		SetPort((GrafPtr)mainWndo);	for (i = 1; i < 65; i++)	{		PenPat(&qd.black);		FrameRect(&tempRect);		InsetRect(&tempRect, -1, -1);		PenPat(&qd.white);		FrameRect(&tempRect);	}	PenNormal();	SetPort((GrafPtr)wasPort);		tempRect = replayRect;	tempRect.top = tempRect.bottom - 4;	for (i = 0; i < 32; i++)	{		if (isColor)			CopyBits(&((GrafPtr)offCWorkPtr)->portBits, &(((GrafPtr)mainWndo)->portBits), 					&tempRect, &tempRect, srcCopy, nil);		else			CopyBits(&offWorkBits, &(mainWndo->portBits), &tempRect, &tempRect, 					srcCopy, nil);				tempRect.top -= 4;		tempRect.bottom -= 4;	}		DrawClosedMouth(0);	DrawOpenHand();		while (Button())	{	}		StartCrowdSound();		if (!Button() && (soundFileRefNum != -1))	{		theSound = GetResource('SMSD', kLadiesSound);		if (theSound != kNilPointer)		{			HLock(theSound);			if (soundOn)				SMSSTART(kLadiesSound);						DrawOpenHand();			DrawOpenMouth(8);			DrawClosedMouth(4);			DrawOpenMouth(8);			DrawClosedHand();			DrawClosedMouth(70);						HUnlock(theSound);			ReleaseResource(theSound);		}	}		if (!Button() && (soundFileRefNum != -1))	{		theSound = GetResource('SMSD', kAndSound);		if (theSound != kNilPointer)		{			HLock(theSound);			if (soundOn)				SMSSTART(kAndSound);						DrawOpenHand();			DrawOpenMouth(50);			DrawClosedHand();			DrawClosedMouth(40);						HUnlock(theSound);			ReleaseResource(theSound);		}	}		if (!Button() && (soundFileRefNum != -1))	{		theSound = GetResource('SMSD', kGentlemenSound);		if (theSound != kNilPointer)		{			HLock(theSound);			if (soundOn)				SMSSTART(kGentlemenSound);						DrawOpenHand();			DrawOpenMouth(10);			DrawClosedMouth(6);			DrawOpenMouth(10);			DrawClosedMouth(6);			DrawOpenMouth(30);			DrawClosedHand();			DrawClosedMouth(28);						HUnlock(theSound);			ReleaseResource(theSound);		}	}		if (!Button() && (soundFileRefNum != -1))	{		theSound = GetResource('SMSD', kParSound);		if (theSound != kNilPointer)		{			HLock(theSound);			if (soundOn)				SMSSTART(kParSound);						DrawOpenHand();			DrawOpenMouth(50);			DrawClosedHand();			DrawClosedMouth(50);						HUnlock(theSound);			ReleaseResource(theSound);		}	}		if (!Button() && (soundFileRefNum != -1))	{		theSound = GetResource('SMSD', kASound);		if (theSound != kNilPointer)		{			HLock(theSound);			if (soundOn)				SMSSTART(kASound);						DrawOpenHand();			DrawOpenMouth(50);			DrawClosedHand();			DrawClosedMouth(40);						HUnlock(theSound);			ReleaseResource(theSound);		}	}		StartApplauseSound();	HoldIt(kApplauseSwellTicks);	Applaud();		if (!Button() && (soundFileRefNum != -1))	{		theSound = GetResource('SMSD', kRenaSound);		if (theSound != kNilPointer)		{			HLock(theSound);			if (soundOn)				SMSSTART(kRenaSound);						DrawOpenHand();			DrawOpenMouth(16);			DrawClosedMouth(8);			DrawOpenMouth(96);			DrawClosedMouth(0);						HUnlock(theSound);			ReleaseResource(theSound);		}	}		InsetRect(&replayRect, -1, -1);	if (isColor)	{		CopyBits(&((GrafPtr)offCBackPtr)->portBits, &((GrafPtr)offCWorkPtr)->portBits, 				&replayRect, &replayRect, srcCopy, nil);		CopyBits(&((GrafPtr)offCWorkPtr)->portBits, &(((GrafPtr)mainWndo)->portBits), 				&replayRect, &replayRect, srcCopy, nil);	}	else	{		CopyBits(&offBackBits, &offWorkBits, &replayRect, &replayRect, 				srcCopy, nil);		CopyBits(&offWorkBits, &(mainWndo->portBits), &replayRect, &replayRect, 				srcCopy, nil);	}	InsetRect(&replayRect, 1, 1);		crowdQueue.number = kCrowdFadeSound;	crowdQueue.when = 300;}/*========================================================  DoNew  */void DoNew (void){		switch (primaryMode)	{		case kIdleMode:			primaryMode = kPlayMode;			newGame = TRUE;			break;		case kPlayMode:			break;	}}/*========================================================  UpdateInstantReplay  */void UpdateReplayDialog (DialogPtr theDialog){	PicHandle		thePict;	Str255			theTitle;	Handle			iHandle;	Rect			iRect;	short			iType;		DrawDialog(theDialog);		GetDItem(theDialog, kUserBalloonReplay, &iType, &iHandle, &iRect);	if (isColor)		thePict = GetPicture(kBalloon4PictID);	else		thePict = GetPicture(kBalloon1PictID);	if (thePict != kNilPointer)	{		DrawPicture(thePict, &iRect);		ReleaseResource((Handle)thePict);	}		GetIndString(theTitle, rMiscStrings, 1);	if (theTitle[0] == 0)		PasStringCopy((StringPtr)"\pInstant ReplayÉ", (StringPtr)theTitle);	MoveTo(kReplayTitleLeft, kReplayTitleTop);	DrawString(theTitle);		DrawDefaultButton(theDialog, kButtReplayOkay);	}/*========================================================  ReplayFilter  */pascal Boolean ReplayFilter (DialogPtr theDialog, EventRecord *theEvent, short *itemHit){	switch (theEvent->what)	{		case keyDown:			switch ((theEvent->message) & charCodeMask)			{				case kReturnKeyASCII:				case kEnterKeyASCII:					FlashDialogButton(theDialog, kButtReplayOkay);					*itemHit = kButtReplayOkay;					return(TRUE);					break;				default:					return(FALSE);			}			break;		case updateEvt:			BeginUpdate((GrafPtr)theDialog);			UpdateReplayDialog(theDialog);			EndUpdate((GrafPtr)theDialog);			theEvent->what = nullEvent;			return(FALSE);			break;		default:			return(FALSE);			break;	}}/*========================================================  ConfigureInstantReplay  */Boolean ConfigureInstantReplay (void){	DialogPtr		replayDialog;	Handle			iHandle;	Rect			iRect;	short			itemHit, iType;	Boolean			leaveDialog, userOkayed, wasState;		CenterDialog(rReplayDialogID);	if (doZooms)		ZoomOutDialogRect(rReplayDialogID);	replayDialog = GetNewDialog(rReplayDialogID, kNilPointer, kPutInFront);	SetPort((GrafPtr)replayDialog);	ShowWindow((GrafPtr)replayDialog);		UpdateReplayDialog(replayDialog);		GetDItem(replayDialog, kCheckGoals, &iType, &iHandle, &iRect);	SetCtlValue((ControlHandle)iHandle, (short)replayGoals);		GetDItem(replayDialog, kCheckFouls, &iType, &iHandle, &iRect);	SetCtlValue((ControlHandle)iHandle, (short)replayFouls);		GetDItem(replayDialog, kCheckOnR, &iType, &iHandle, &iRect);	SetCtlValue((ControlHandle)iHandle, (short)replayOnR);		GetDItem(replayDialog, kCheckReplayZooms, &iType, &iHandle, &iRect);	SetCtlValue((ControlHandle)iHandle, (short)replayZooms);		leaveDialog = FALSE;		while (!leaveDialog)	{		ModalDialog(ReplayFilter, &itemHit);				switch (itemHit)		{			case kButtReplayOkay:				GetDItem(replayDialog, kCheckGoals, &iType, &iHandle, &iRect);				replayGoals = (Boolean)GetCtlValue((ControlHandle)iHandle);								GetDItem(replayDialog, kCheckFouls, &iType, &iHandle, &iRect);				replayFouls = (Boolean)GetCtlValue((ControlHandle)iHandle);								GetDItem(replayDialog, kCheckOnR, &iType, &iHandle, &iRect);				replayOnR = (Boolean)GetCtlValue((ControlHandle)iHandle);								GetDItem(replayDialog, kCheckReplayZooms, &iType, &iHandle, &iRect);				replayZooms = (Boolean)GetCtlValue((ControlHandle)iHandle);								replaySomething = replayGoals || replayFouls || replayOnR;								userOkayed = TRUE;				leaveDialog = TRUE;				break;							case kButtReplayCancel:				userOkayed = FALSE;				leaveDialog = TRUE;				break;							case kCheckGoals:			case kCheckFouls:			case kCheckOnR:			case kCheckReplayZooms:				GetDItem(replayDialog, itemHit, &iType, &iHandle, &iRect);				wasState = (Boolean)GetCtlValue((ControlHandle)iHandle);				wasState = !wasState;				SetCtlValue((ControlHandle)iHandle, (short)wasState);				break;							default:				break;		}	}		DisposDialog(replayDialog);	return (userOkayed);}/*========================================================  UpdateNamesDialog  */void UpdateNamesDialog (DialogPtr theDialog){	PicHandle		thePict;	Str255			theTitle;	Handle			iHandle;	Rect			iRect;	short			iType;		DrawDialog(theDialog);		GetDItem(theDialog, kUserBalloonNames, &iType, &iHandle, &iRect);	if (isColor)		thePict = GetPicture(kBalloon4PictID);	else		thePict = GetPicture(kBalloon1PictID);	if (thePict != kNilPointer)	{		DrawPicture(thePict, &iRect);		ReleaseResource((Handle)thePict);	}		GetIndString(theTitle, rMiscStrings, 3);	if (theTitle[0] == 0)		PasStringCopy((StringPtr)"\pEdit NamesÉ", (StringPtr)theTitle);	MoveTo(kNamesTitleLeft, kNamesTitleTop);	DrawString(theTitle);		DrawDefaultButton(theDialog, kButtNamesOkay);}/*========================================================  EditNameFilter  */pascal Boolean EditNameFilter (DialogPtr theDialog, EventRecord *theEvent, short *itemHit){	switch (theEvent->what)	{		case keyDown:			switch ((theEvent->message) & charCodeMask)			{				case kReturnKeyASCII:				case kEnterKeyASCII:					FlashDialogButton(theDialog, kButtNamesOkay);					*itemHit = kButtNamesOkay;					return(TRUE);					break;				default:					return(FALSE);			}			break;		case updateEvt:			BeginUpdate((GrafPtr)theDialog);			UpdateNamesDialog(theDialog);			EndUpdate((GrafPtr)theDialog);			theEvent->what = nullEvent;			return(FALSE);			break;		default:			return(FALSE);			break;	}}/*========================================================  ConfigureNames  */Boolean ConfigureNames (void){	DialogPtr		namesDialog;	Handle			iHandle;	Rect			iRect;	Str255			tempStr;	short			itemHit, iType, i, blewIt;	Boolean			leaveDialog, userOkayed;		CenterDialog(rNamesDialogID);	if (doZooms)		ZoomOutDialogRect(rNamesDialogID);	namesDialog = GetNewDialog(rNamesDialogID, kNilPointer, kPutInFront);	SetPort((GrafPtr)namesDialog);	ShowWindow((GrafPtr)namesDialog);		UpdateNamesDialog(namesDialog);		for (i = 0; i < 10; i++)	{		GetDItem(namesDialog, kEditFirstName + i, &iType, &iHandle, &iRect);		SetIText(iHandle, (StringPtr)theNames[i]);	}		SelIText(namesDialog, kEditFirstName + whichHumanNumber - 1, 0, 32767);		leaveDialog = FALSE;		while (!leaveDialog)	{		ModalDialog(EditNameFilter, &itemHit);				switch (itemHit)		{			case kButtNamesOkay:				blewIt = -1;				for (i = 0; i < 10; i++)				{					GetDItem(namesDialog, kEditFirstName + i, &iType, &iHandle, &iRect);					GetIText(iHandle, tempStr);					if (tempStr[0] > 31)						blewIt = i;				}				if (blewIt == -1)				{					for (i = 0; i < 10; i++)					{						GetDItem(namesDialog, kEditFirstName + i, &iType, &iHandle, &iRect);						GetIText(iHandle, (StringPtr)theNames[i]);					}					userOkayed = TRUE;					leaveDialog = TRUE;				}				else				{					SysBeep(20);					SelIText(namesDialog, kEditFirstName + blewIt, 0, 32767);				}				break;							case kButtNamesCancel:				userOkayed = FALSE;				leaveDialog = TRUE;				break;							default:				break;		}	}		DisposDialog(namesDialog);	return (userOkayed);}/*========================================================  UpdatePrefsDialog  */void UpdatePrefsDialog (DialogPtr theDialog){	PicHandle		thePict;	Str255			theTitle;	Handle			iHandle;	Rect			iRect;	short			iType;		DrawDialog(theDialog);		GetDItem(theDialog, kUserBalloonPrefs, &iType, &iHandle, &iRect);	if (isColor)		thePict = GetPicture(kBalloon4PictID);	else		thePict = GetPicture(kBalloon1PictID);	if (thePict != kNilPointer)	{		DrawPicture(thePict, &iRect);		ReleaseResource((Handle)thePict);	}		GetIndString(theTitle, rMiscStrings, 2);	if (theTitle[0] == 0)		PasStringCopy((StringPtr)"\pPreferencesÉ", (StringPtr)theTitle);	MoveTo(kPrefsTitleLeft, kPrefsTitleTop);	DrawString(theTitle);		DrawDefaultButton(theDialog, kButtPrefsOkay);}/*========================================================  PrefsFilter  */pascal Boolean PrefsFilter (DialogPtr theDialog, EventRecord *theEvent, short *itemHit){	switch (theEvent->what)	{		case keyDown:			switch ((theEvent->message) & charCodeMask)			{				case kReturnKeyASCII:				case kEnterKeyASCII:					FlashDialogButton(theDialog, kButtPrefsOkay);					*itemHit = kButtPrefsOkay;					return(TRUE);					break;				default:					return(FALSE);			}			break;		case updateEvt:			BeginUpdate((GrafPtr)theDialog);			UpdatePrefsDialog(theDialog);			EndUpdate((GrafPtr)theDialog);			theEvent->what = nullEvent;			return(FALSE);			break;		default:			return(FALSE);			break;	}}/*========================================================  ConfigurePreferences  */Boolean ConfigurePreferences (void){	DialogPtr		prefsDialog;	Handle			iHandle;	Rect			iRect;	short			itemHit, iType;	Boolean			leaveDialog, userOkayed, wasState;		CenterDialog(rPrefsDialogID);	if (doZooms)		ZoomOutDialogRect(rPrefsDialogID);	prefsDialog = GetNewDialog(rPrefsDialogID, kNilPointer, kPutInFront);		SetPort((GrafPtr)prefsDialog);	ShowWindow((GrafPtr)prefsDialog);		UpdatePrefsDialog(prefsDialog);		GetDItem(prefsDialog, kCheckUseQD, &iType, &iHandle, &iRect);	SetCtlValue((ControlHandle)iHandle, (short)willUseQD);		GetDItem(prefsDialog, kCheckCursor, &iType, &iHandle, &iRect);	SetCtlValue((ControlHandle)iHandle, (short)showBoardCursor);		GetDItem(prefsDialog, kCheckDepth, &iType, &iHandle, &iRect);	SetCtlValue((ControlHandle)iHandle, (short)autoSetDepth);	if (!thisMac.hasColor)		HiliteControl((ControlHandle)iHandle, kInactive);		GetDItem(prefsDialog, kCheckAnnouncer, &iType, &iHandle, &iRect);	SetCtlValue((ControlHandle)iHandle, (short)(!enableAnnouncer));	if (soundFileRefNum == -1)		HiliteControl((ControlHandle)iHandle, kInactive);		GetDItem(prefsDialog, kCheckBackground, &iType, &iHandle, &iRect);	SetCtlValue((ControlHandle)iHandle, (short)(enableBackground));		GetDItem(prefsDialog, kCheckZooms, &iType, &iHandle, &iRect);	SetCtlValue((ControlHandle)iHandle, (short)(doZooms));		GetDItem(prefsDialog, kCheckSkip, &iType, &iHandle, &iRect);	SetCtlValue((ControlHandle)iHandle, (short)(doSkipFrames));		leaveDialog = FALSE;		while (!leaveDialog)	{		ModalDialog(PrefsFilter, &itemHit);				switch (itemHit)		{			case kButtPrefsOkay:				GetDItem(prefsDialog, kCheckUseQD, &iType, &iHandle, &iRect);				willUseQD = (Boolean)GetCtlValue((ControlHandle)iHandle);								GetDItem(prefsDialog, kCheckCursor, &iType, &iHandle, &iRect);				showBoardCursor = (Boolean)GetCtlValue((ControlHandle)iHandle);								GetDItem(prefsDialog, kCheckDepth, &iType, &iHandle, &iRect);				autoSetDepth = (Boolean)GetCtlValue((ControlHandle)iHandle);								GetDItem(prefsDialog, kCheckAnnouncer, &iType, &iHandle, &iRect);				enableAnnouncer = !(Boolean)GetCtlValue((ControlHandle)iHandle);								GetDItem(prefsDialog, kCheckBackground, &iType, &iHandle, &iRect);				enableBackground = (Boolean)GetCtlValue((ControlHandle)iHandle);								GetDItem(prefsDialog, kCheckZooms, &iType, &iHandle, &iRect);				doZooms = (Boolean)GetCtlValue((ControlHandle)iHandle);								GetDItem(prefsDialog, kCheckSkip, &iType, &iHandle, &iRect);				doSkipFrames = (Boolean)GetCtlValue((ControlHandle)iHandle);								userOkayed = TRUE;				leaveDialog = TRUE;				break;							case kButtPrefsCancel:				userOkayed = FALSE;				leaveDialog = TRUE;				break;							case kCheckUseQD:			case kCheckCursor:			case kCheckDepth:			case kCheckAnnouncer:			case kCheckBackground:			case kCheckZooms:			case kCheckSkip:				GetDItem(prefsDialog, itemHit, &iType, &iHandle, &iRect);				wasState = (Boolean)GetCtlValue((ControlHandle)iHandle);				wasState = !wasState;				SetCtlValue((ControlHandle)iHandle, (short)wasState);				break;							default:				break;		}	}		DisposDialog(prefsDialog);	return (userOkayed);}/*========================================================  UpdateRecordsDialog  */void UpdateRecordsDialog (DialogPtr theDialog){	PicHandle		thePict;	Str255			theTitle;	Handle			iHandle;	Rect			iRect;	short			iType, i;		DrawDialog(theDialog);		GetDItem(theDialog, kUserBalloonRecords, &iType, &iHandle, &iRect);	if (isColor)		thePict = GetPicture(kBalloon4PictID);	else		thePict = GetPicture(kBalloon1PictID);	if (thePict != kNilPointer)	{		DrawPicture(thePict, &iRect);		ReleaseResource((Handle)thePict);	}		GetIndString(theTitle, rMiscStrings, 7);	if (theTitle[0] == 0)		PasStringCopy((StringPtr)"\pWorld RecordsÉ", (StringPtr)theTitle);	MoveTo(kRecordsTitleLeft, kRecordsTitleTop);	DrawString(theTitle);		DrawDefaultButton(theDialog, kButtRecordsOkay);		ForeColor(cyanColor);	for (i = kUserFirstFrameRecords; i <= kUserLastFrameRecords; i++)	{		GetDItem(theDialog, i, &iType, &iHandle, &iRect);		FrameRect(&iRect);	}	ForeColor(blackColor);}/*========================================================  RecordsFilter  */pascal Boolean RecordsFilter (DialogPtr theDialog, EventRecord *theEvent, short *itemHit){	switch (theEvent->what)	{		case keyDown:			switch ((theEvent->message) & charCodeMask)			{				case kReturnKeyASCII:				case kEnterKeyASCII:					FlashDialogButton(theDialog, kButtRecordsOkay);					*itemHit = kButtRecordsOkay;					return(TRUE);					break;				default:					return(FALSE);			}			break;		case updateEvt:			BeginUpdate((GrafPtr)theDialog);			UpdateRecordsDialog(theDialog);			EndUpdate((GrafPtr)theDialog);			theEvent->what = nullEvent;			return(FALSE);			break;		default:			return(FALSE);			break;	}}/*========================================================  DisplayRecords  */Boolean DisplayRecords (void){	DialogPtr		recordsDialog;	Handle			iHandle;	Rect			iRect;	Str255			theDate;	short			itemHit, iType, i;	Boolean			leaveDialog, userOkayed;		CenterDialog(rRecordsDialogID);	if (doZooms)		ZoomOutDialogRect(rRecordsDialogID);	recordsDialog = GetNewDialog(rRecordsDialogID, kNilPointer, kPutInFront);	SetPort((GrafPtr)recordsDialog);	ShowWindow((GrafPtr)recordsDialog);		UpdateRecordsDialog(recordsDialog);		ForeColor(blueColor);	SetDialogString (recordsDialog, kNameRecordsTitles, (StringPtr)mostTitlesName);	SetDialogString (recordsDialog, kNameRecordsPoints, (StringPtr)mostPointsName);	SetDialogString (recordsDialog, kNameRecordsFouls, (StringPtr)mostFoulsName);	SetDialogString (recordsDialog, kNameRecordsCrits, (StringPtr)mostCritsName);		SetDialogNumToStr (recordsDialog, kAmountRecordsTitles, (long)mostTitles);	SetDialogNumToStr (recordsDialog, kAmountRecordsPoints, (long)mostPoints);	SetDialogNumToStr (recordsDialog, kAmountRecordsFouls, (long)mostFouls);	SetDialogNumToStr (recordsDialog, kAmountRecordsCrits, (long)mostCrits);		USSecsToDateString(mostTitlesDate, theDate);	SetDialogString (recordsDialog, kDateRecordsTitles, theDate);	USSecsToDateString(mostPointsDate, theDate);	SetDialogString (recordsDialog, kDateRecordsPoints, theDate);	USSecsToDateString(mostFoulsDate, theDate);	SetDialogString (recordsDialog, kDateRecordsFouls, theDate);	USSecsToDateString(mostCritsDate, theDate);	SetDialogString (recordsDialog, kDateRecordsCrits, theDate);	ForeColor(blackColor);		leaveDialog = FALSE;		while (!leaveDialog)	{		ModalDialog(RecordsFilter, &itemHit);				switch (itemHit)		{			case kButtRecordsOkay:				userOkayed = TRUE;				leaveDialog = TRUE;				break;			case kUserHiddenReset:				ResetWorldRecords();				break;			default:				break;		}	}		DisposDialog(recordsDialog);	return (userOkayed);}/*========================================================  UpdateMemoryDialog  */void UpdateMemoryDialog (DialogPtr theDialog){	PicHandle		thePict;	Str255			theTitle;	Handle			iHandle;	Rect			iRect;	short			iType;		DrawDialog(theDialog);		GetDItem(theDialog, kUserBalloonMemory, &iType, &iHandle, &iRect);	if (isColor)		thePict = GetPicture(kBalloon4PictID);	else		thePict = GetPicture(kBalloon1PictID);	if (thePict != kNilPointer)	{		DrawPicture(thePict, &iRect);		ReleaseResource((Handle)thePict);	}		GetIndString(theTitle, rMiscStrings, 10);	if (theTitle[0] == 0)		PasStringCopy((StringPtr)"\pMemory InfoÉ", (StringPtr)theTitle);	MoveTo(kMemoryTitleLeft, kMemoryTitleTop);	DrawString(theTitle);		DrawDefaultButton(theDialog, kButtMemoryOkay);}/*========================================================  MemoryFilter  */pascal Boolean MemoryFilter (DialogPtr theDialog, EventRecord *theEvent, short *itemHit){	switch (theEvent->what)	{		case keyDown:			switch ((theEvent->message) & charCodeMask)			{				case kReturnKeyASCII:				case kEnterKeyASCII:					FlashDialogButton(theDialog, kButtMemoryOkay);					*itemHit = kButtMemoryOkay;					return(TRUE);					break;				default:					return(FALSE);			}			break;		case updateEvt:			BeginUpdate((GrafPtr)theDialog);			UpdateMemoryDialog(theDialog);			EndUpdate((GrafPtr)theDialog);			theEvent->what = nullEvent;			return(FALSE);			break;		default:			return(FALSE);			break;	}}/*========================================================  DisplayMemory  */Boolean DisplayMemory (void){	DialogPtr		memoryDialog;	Handle			iHandle;	Rect			iRect;	Str255			aString;	long			freeMemory;	short			itemHit, iType, i, lastPrimarySound, lastIncidentalSound;	Boolean			leaveDialog, userOkayed, showTime;		showTime = OptionKeyIsDown();		CenterDialog(rMemoryDialogID);	if (doZooms)		ZoomOutDialogRect(rMemoryDialogID);	memoryDialog = GetNewDialog(rMemoryDialogID, kNilPointer, kPutInFront);	SetPort((GrafPtr)memoryDialog);	ShowWindow((GrafPtr)memoryDialog);		UpdateMemoryDialog(memoryDialog);		lastPrimarySound = 0;	for (i = 1; i < kMaxNumberOfSounds; i++)	{		if (soundLoaded[i] == TRUE)			lastPrimarySound = i;	}		lastIncidentalSound = 0;	for (i = 0; i < kMaxIncidentalSounds; i++)	{		if (incidentSoundLoaded[i] == TRUE)			lastIncidentalSound = i + 1;	}		freeMemory = FreeMem() / 1024L;		ForeColor(blueColor);	SetDialogNumToStr (memoryDialog, kTextPrimarySounds, (long)lastPrimarySound);	SetDialogNumToStr (memoryDialog, kTextIncidentalSounds, (long)lastIncidentalSound);	SetDialogNumToStr (memoryDialog, kTextFreeMemory, (long)freeMemory);	ForeColor(blackColor);		if (showTime)	{		MoveTo(16, 160);		NumToString((lifeTime / 3600), aString);		DrawString(aString);	}		leaveDialog = FALSE;		while (!leaveDialog)	{		ModalDialog(MemoryFilter, &itemHit);				switch (itemHit)		{			case kButtMemoryOkay:				userOkayed = TRUE;				leaveDialog = TRUE;				break;						default:				break;		}	}		DisposDialog(memoryDialog);	return (userOkayed);}/*========================================================  UpdateLeagueDialog  */void UpdateLeagueDialog (DialogPtr theDialog){	PicHandle		thePict;	Str255			theTitle;	Handle			iHandle;	Rect			iRect;	short			iType;		DrawDialog(theDialog);		GetDItem(theDialog, kUserBalloonLeague, &iType, &iHandle, &iRect);	if (isColor)		thePict = GetPicture(kBalloon4PictID);	else		thePict = GetPicture(kBalloon1PictID);	if (thePict != kNilPointer)	{		DrawPicture(thePict, &iRect);		ReleaseResource((Handle)thePict);	}		GetIndString(theTitle, rMiscStrings, 12);	if (theTitle[0] == 0)		PasStringCopy((StringPtr)"\pSelect LeagueÉ", (StringPtr)theTitle);	MoveTo(kLeagueTitleLeft, kLeagueTitleTop);	DrawString(theTitle);		DrawDefaultButton(theDialog, kButtLeagueOkay);}/*========================================================  LeagueFilter  */pascal Boolean LeagueFilter (DialogPtr theDialog, EventRecord *theEvent, short *itemHit){	switch (theEvent->what)	{		case keyDown:			switch ((theEvent->message) & charCodeMask)			{				case kReturnKeyASCII:				case kEnterKeyASCII:					FlashDialogButton(theDialog, kButtLeagueOkay);					*itemHit = kButtLeagueOkay;					return(TRUE);					break;				default:					return(FALSE);			}			break;		case updateEvt:			BeginUpdate((GrafPtr)theDialog);			UpdateLeagueDialog(theDialog);			EndUpdate((GrafPtr)theDialog);			theEvent->what = nullEvent;			return(FALSE);			break;		default:			return(FALSE);			break;	}}/*========================================================  ConfigureLeague  */Boolean ConfigureLeague (void){	DialogPtr		leagueDialog;	Handle			iHandle;	Rect			iRect;	short			itemHit, iType, tempLeague;	Boolean			leaveDialog, userOkayed;		CenterDialog(rLeagueDialogID);	if (doZooms)		ZoomOutDialogRect(rLeagueDialogID);	leagueDialog = GetNewDialog(rLeagueDialogID, kNilPointer, kPutInFront);	SetPort((GrafPtr)leagueDialog);	ShowWindow((GrafPtr)leagueDialog);		UpdateLeagueDialog(leagueDialog);	tempLeague = isLeague;		#if kDemoVersion		tempLeague = kLittleLeague;		DisableControl(leagueDialog, kRadioJrVarsity);		DisableControl(leagueDialog, kRadioVarsity);		DisableControl(leagueDialog, kRadioMinorLeague);		DisableControl(leagueDialog, kRadioProfessional);	#endif		SelectFromRadioGroup (leagueDialog, tempLeague + kRadioLittleLeague, 			kRadioLittleLeague, kRadioProfessional);		leaveDialog = FALSE;		while (!leaveDialog)	{		ModalDialog(LeagueFilter, &itemHit);				switch (itemHit)		{			case kButtLeagueOkay:				if (isLeague != tempLeague)				{					userOkayed = TRUE;					isLeague = tempLeague;					#if kDemoVersion						isLeague = kLittleLeague;					#endif				}				else				{					userOkayed = FALSE;				}				leaveDialog = TRUE;				break;						case kButtLeagueCancel:				userOkayed = FALSE;				leaveDialog = TRUE;				break;						case kRadioLittleLeague:			case kRadioJrVarsity:			case kRadioVarsity:			case kRadioMinorLeague:			case kRadioProfessional:				tempLeague = itemHit - kRadioLittleLeague;				SelectFromRadioGroup (leagueDialog, itemHit, kRadioLittleLeague, 						kRadioProfessional);				break;						default:				break;		}	}		DisposDialog(leagueDialog);	return (userOkayed);}/*========================================================  ConvertPararena  */Boolean ConvertPararena (void){	#define		rConvertParaALRT 1012	Str255		theText;	short		sheWants;	Boolean		doOrDont, wereLegit;		if (netOnly)		GetIndString(theText, rMiscStrings, 21);	else		GetIndString(theText, rMiscStrings, 22);		if (theText[0] != 0)		ParamText(theText, "\p", "\p", "\p");	CenterAlert(rConvertParaALRT);	sheWants = Alert(rConvertParaALRT, kNilPointer);		if (sheWants == 1)	{		doOrDont = FALSE;	}	else	{		doOrDont = TRUE;		if (netOnly)		{			wereLegit = ValidInstallation(FALSE);			if (wereLegit)			{				netOnly = FALSE;				if (!canNetwork)				{					thePlayer.persona = kHumanPlayer;					theOpponent.persona = kMissTeak;					leftPlayerNumber = kHumanPlayer;					rightPlayerNumber = theOpponent.persona;					MinorError(kMinorCantNetDefault);				}			}			else			{				thePlayer.persona = kHumanPlayer;				theOpponent.persona = kNetHuman;				leftPlayerNumber = kHumanPlayer;				rightPlayerNumber = theOpponent.persona;				whichGame = kStandardGame;				encryptedNumber = 0L;				netOnly = TRUE;			}		}		else		{			if (!canNetwork)				MinorError(kMinorCantNetAndNetOnly);			thePlayer.persona = kHumanPlayer;			theOpponent.persona = kNetHuman;			leftPlayerNumber = kHumanPlayer;			rightPlayerNumber = theOpponent.persona;			whichGame = kStandardGame;			encryptedNumber = 0L;			netOnly = TRUE;		}	}		return (doOrDont);}