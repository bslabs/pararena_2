/*============================================================*//*============================================================*//*==														==*//*==				Initialization Routines					==*//*==														==*//*============================================================*//*============================================================*//*========================================================  Includes  */#include "UnivUtilities.h"#include "Globals.h"#include "AppleTalkDDP.h"#include "Initialize.h"#include "AnimCursor.h"#include "MainWindow.h"#include <Sound.h>#include "Render.h"#include "Environ.h"#include "InitGameStructs.h"#include "TeamSetUp.h"#include "Menu.h"#include "ValidInstall.h"/*========================================================  ToolBoxInit  */void ToolBoxInit (void){	short		count;		InitGraf(&thePort);	InitFonts();	FlushEvents(everyEvent, kRemoveAllEvents);	InitWindows();	InitMenus();	TEInit();	InitDialogs(kNilPointer);	InitCursor();		MaxApplZone();		MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();		for (count = 1; count <= 3; count++)		EventAvail(everyEvent, &theEvent);	inBackground = FALSE;}/*========================================================  BitMapInit  */void BitMapInit (void){	PicHandle	thePict;	short		mapWidth, mapHeight;		SpinCursor(7);/* Set up offscreen bit map for various game objects */	offPartsPtr = (GrafPtr)(NewPtr(sizeof(GrafPort)));	OpenPort(offPartsPtr);	mapWidth = 400;	mapHeight = 264;	SetRect(&offPartsRect, 0, 0, mapWidth, mapHeight);	partsRowBytes = ((offPartsRect.right - offPartsRect.left + 15) / 16) * 2;	offPartsBits.rowBytes = partsRowBytes;	offPartsBits.bounds = offPartsRect;	offPartsBits.baseAddr = NewPtr((long)offPartsBits.rowBytes * 		(offPartsRect.bottom - offPartsRect.top));	if (offPartsBits.baseAddr == kNilPointer)		DeathError(kErrNoMemory);	if (MemError() != noErr)		DeathError(kErrNoMemory);	SetPortBits(&offPartsBits);	ClipRect(&offPartsRect);	EraseRect(&offPartsRect);		thePict = GetPicture(rPartsPict1BitID);	if (thePict != kNilPointer)	{		DrawPicture(thePict, &offPartsRect);		ReleaseResource((Handle)thePict);	}	else		DeathError(kErrNoPictRsrc);	/* Set up offscreen bit map for preloading assembled graphics */	offWorkPtr = (GrafPtr)(NewPtr(sizeof(GrafPort)));	OpenPort(offWorkPtr);	mapWidth = screenWide;	mapHeight = screenHigh;	SetRect(&offWorkRect, 0, 0, mapWidth, mapHeight);	workRowBytes = ((offWorkRect.right - offWorkRect.left + 15) / 16) * 2;	offWorkBits.rowBytes = workRowBytes;	offWorkBits.bounds = offWorkRect;	offWorkBits.baseAddr = NewPtr((long)offWorkBits.rowBytes * 		(offWorkRect.bottom - offWorkRect.top));	if (offWorkBits.baseAddr == kNilPointer)		DeathError(kErrNoMemory);	if (MemError() != noErr)		DeathError(kErrNoMemory);	SetPortBits(&offWorkBits);	ClipRect(&offWorkRect);	EraseRect(&offWorkRect);/* Set up offscreen bit map for a virgin copy of background */	offBackPtr = (GrafPtr)(NewPtr(sizeof(GrafPort)));	OpenPort(offBackPtr);	mapWidth = screenWide;	mapHeight = screenHigh;	SetRect(&offBackRect, 0, 0, mapWidth, mapHeight);	backRowBytes = ((offBackRect.right - offBackRect.left + 15) / 16) * 2;	offBackBits.rowBytes = backRowBytes;	offBackBits.bounds = offBackRect;	offBackBits.baseAddr = NewPtr((long)offBackBits.rowBytes * 		(offBackRect.bottom - offBackRect.top));	if (offBackBits.baseAddr == kNilPointer)		DeathError(kErrNoMemory);	if (MemError() != noErr)		DeathError(kErrNoMemory);	SetPortBits(&offBackBits);	ClipRect(&offBackRect);	EraseRect(&offBackRect);		LoadBackgroundPict();		CopyBits(&offBackBits, &offWorkBits, &offBackRect, &offBackRect, srcCopy, nil);		CopyBits(&offBackBits, &offPartsBits, &rightArrowDest, &rightArrowStorage, srcCopy, 			nil);	CopyBits(&offBackBits, &offPartsBits, &leftArrowDest, &leftArrowStorage, srcCopy, 			nil);}/*========================================================  PixMapInit  */void PixMap4Init (void){	GDHandle	thisGDevice;	CTabHandle	thisCMHandle;	PicHandle	thePict;	Rect		pictRect;	long		sizeOfOff;	OSErr		theErr;	short		theDepth, mapWidth, mapHeight;		SpinCursor(7);		thisGDevice = GetMainDevice();		offCPartsPtr = &offCPartsPort;		/* set up parts port */	OpenCPort(offCPartsPtr);	theDepth = 4;	mapWidth = 400;	mapHeight = 264;	SetRect (&offPartsRect, 0, 0, mapWidth, mapHeight);	partsRowBytes = (((theDepth * mapWidth) + 15) >> 4) << 1;	sizeOfOff = (long)mapHeight * (long)partsRowBytes;	offPartsPix = NewPtr(sizeOfOff);	if (offPartsPix == kNilPointer)	{		DeathError(kErrNoMemory);	}	(**(*offCPartsPtr).portPixMap).baseAddr = offPartsPix;	(**(*offCPartsPtr).portPixMap).rowBytes = (short)partsRowBytes + 0x8000;	(**(*offCPartsPtr).portPixMap).bounds = offPartsRect;	SetPort((GrafPtr)offCPartsPtr);	ClipRect(&offPartsRect);		thisCMHandle = (**(**thisGDevice).gdPMap).pmTable;	theErr = HandToHand((Handle *)&thisCMHandle);	if (theErr != noErr)		DeathError(kErrNoMemory);		(**(*offCPartsPtr).portPixMap).pmTable = thisCMHandle;		PmForeColor(kBlackColor4Bit);	PmBackColor(kWhiteColor4Bit);		thePict = GetPicture(rPartsPict4BitID);	if (thePict != kNilPointer)	{		DrawPicture(thePict, &offPartsRect);		ReleaseResource((Handle)thePict);	}	else		DeathError(kErrNoPictRsrc);			/* set up work port for pre-graphics */	offCWorkPtr = &offCWorkPort;	OpenCPort(offCWorkPtr);	theDepth = 4;	mapWidth = screenWide;	mapHeight = screenHigh;	SetRect (&offWorkRect, 0, 0, mapWidth, mapHeight);	workRowBytes = (((theDepth * mapWidth) + 15) >> 4) << 1;	sizeOfOff = (long)mapHeight * (long)workRowBytes;	offWorkPix = NewPtr(sizeOfOff);	if (offWorkPix == kNilPointer)	{		DeathError(kErrNoMemory);	}	(**(*offCWorkPtr).portPixMap).baseAddr = offWorkPix;	(**(*offCWorkPtr).portPixMap).rowBytes = workRowBytes + 0x8000;	(**(*offCWorkPtr).portPixMap).bounds = offWorkRect;	SetPort((GrafPtr)offCWorkPtr);	ClipRect(&offWorkRect);		thisCMHandle = (**(**thisGDevice).gdPMap).pmTable;	theErr = HandToHand((Handle *)&thisCMHandle);	if (theErr != noErr)		DeathError(kErrNoMemory);		(**(*offCPartsPtr).portPixMap).pmTable = thisCMHandle;		PmForeColor(kBlackColor4Bit);	PmBackColor(kWhiteColor4Bit);	/* set up background port */	offCBackPtr = &offCBackPort;	OpenCPort(offCBackPtr);	theDepth = 4;	mapWidth = screenWide;	mapHeight = screenHigh;	SetRect (&offBackRect, 0, 0, mapWidth, mapHeight);	backRowBytes = (((theDepth * mapWidth) + 15) >> 4) << 1;	sizeOfOff = (long)mapHeight * (long)backRowBytes;	offBackPix = NewPtr(sizeOfOff);	if (offBackPix == kNilPointer)	{		DeathError(kErrNoMemory);	}	(**(*offCBackPtr).portPixMap).baseAddr = offBackPix;	(**(*offCBackPtr).portPixMap).rowBytes = backRowBytes + 0x8000;	(**(*offCBackPtr).portPixMap).bounds = offBackRect;	SetPort((GrafPtr)offCBackPtr);	ClipRect(&offBackRect);		thisCMHandle = (**(**thisGDevice).gdPMap).pmTable;	theErr = HandToHand((Handle *)&thisCMHandle);	if (theErr != noErr)		DeathError(kErrNoMemory);		(**(*offCPartsPtr).portPixMap).pmTable = thisCMHandle;		PmForeColor(kBlackColor4Bit);	PmBackColor(kWhiteColor4Bit);		LoadBackgroundPict();		CopyBits(&((GrafPtr)offCBackPtr)->portBits, &((GrafPtr)offCWorkPtr)->portBits, 		&offBackRect, &offBackRect, srcCopy, nil);		CopyBits(&((GrafPtr)offCBackPtr)->portBits, &((GrafPtr)offCPartsPtr)->portBits, 			&rightArrowDest, &rightArrowStorage, srcCopy, nil);	CopyBits(&((GrafPtr)offCBackPtr)->portBits, &((GrafPtr)offCPartsPtr)->portBits, 			&leftArrowDest, &leftArrowStorage, srcCopy, nil);}/*========================================================  MaskMapInit  */void MaskMapInit (void){	PicHandle	thePict;	short		mapWidth, mapHeight;		SpinCursor(7);		offMaskPtr = (GrafPtr)(NewPtr(sizeof(GrafPort)));	OpenPort(offMaskPtr);	mapWidth = 320;	mapHeight = 264;	SetRect(&offMaskRect, 0, 0, mapWidth, mapHeight);	maskRowBytes = ((offMaskRect.right - offMaskRect.left + 15) / 16) * 2;	offMaskMap.rowBytes = maskRowBytes;	offMaskMap.baseAddr = NewPtr((long)offMaskMap.rowBytes * 		(offMaskRect.bottom - offMaskRect.top));	if (offMaskMap.baseAddr == kNilPointer)		DeathError(kErrNoMemory);	offMaskMap.bounds = offMaskRect;	if (MemError() != noErr)		DeathError(kErrNoMemory);	SetPortBits(&offMaskMap);	ClipRect(&offMaskRect);	EraseRect(&offMaskRect);		if (isColor)		thePict = GetPicture(rMaskPict48ID);	else		thePict = GetPicture(rMaskPict1ID);		if (thePict != kNilPointer)	{		DrawPicture(thePict, &offMaskRect);		ReleaseResource((Handle)thePict);	}	else		DeathError(kErrNoPictRsrc);}/*========================================================  MaskPixInit  */void MaskPixInit (void){	GDHandle	thisGDevice;	CTabHandle	thisCMHandle;	PicHandle	thePict;	Rect		pictRect;	long		sizeOfOff;	OSErr		theErr;	short		theDepth, mapWidth, mapHeight;		thisGDevice = GetMainDevice();		offCMaskPtr = &offCMaskPort;		/* set up Mask port */	OpenCPort(offCMaskPtr);	theDepth = 4;	mapWidth = 320;	mapHeight = 264;	SetRect (&offMaskRect, 0, 0, mapWidth, mapHeight);	maskCRowBytes = (((theDepth * mapWidth) + 15) >> 4) << 1;	sizeOfOff = (long)mapHeight * (long)maskCRowBytes;	offMaskPix = NewPtr(sizeOfOff);	if (offMaskPix == kNilPointer)	{		DeathError(kErrNoMemory);	}	(**(*offCMaskPtr).portPixMap).baseAddr = offMaskPix;	(**(*offCMaskPtr).portPixMap).rowBytes = (short)maskCRowBytes + 0x8000;	(**(*offCMaskPtr).portPixMap).bounds = offMaskRect;	SetPort((GrafPtr)offCMaskPtr);	ClipRect(&offMaskRect);		thisCMHandle = (**(**thisGDevice).gdPMap).pmTable;	theErr = HandToHand((Handle *)&thisCMHandle);	if (theErr != noErr)		DeathError(kErrNoMemory);		(**(*offCPartsPtr).portPixMap).pmTable = thisCMHandle;		PmForeColor(kBlackColor4Bit);	PmBackColor(kWhiteColor4Bit);		if (isColor)		thePict = GetPicture(rMaskPict48ID);	else		thePict = GetPicture(rMaskPict1ID);		if (thePict != kNilPointer)	{		DrawPicture(thePict, &offMaskRect);		ReleaseResource((Handle)thePict);	}	else		DeathError(kErrNoPictRsrc);}/*========================================================  GetBaseAddressC  */void GetBaseAddressC (void){	GDHandle		theDevice;	PixMapHandle	pixMapH;	long			insetHPix, insetVPix;	short			i;		theDevice = GetMainDevice();	pixMapH = (**theDevice).gdPMap;	screenBase = (long)((**pixMapH).baseAddr);	screenRowBytes = (**pixMapH).rowBytes & 0x7FFF;		insetHPix = (long)(screenBits.bounds.right - screenBits.bounds.left - screenWide) / 2L;	insetVPix = (long)(screenBits.bounds.bottom - screenBits.bounds.top - screenHigh) / 2L;	insetBytes = (insetVPix * (long)screenRowBytes) + (insetHPix * (long)isDepth / 8L);		for (i = 0; i < 480; i++)		screenRowAddrs[i] = ((long)screenRowBytes * (long)i) + screenBase + 				(long)insetBytes;		for (i = 0; i < 480; i++)		workRowOffsets[i] = (long)workRowBytes * (long)i;		theDoor.srcAddrs[0][0] = ((long)theDoor.srcRects[0][0].top * partsRowBytes) + 			((long)theDoor.srcRects[0][0].left * (long)isDepth / 8L) + (long)offPartsPix;		theDoor.srcAddrs[0][1] = ((long)theDoor.srcRects[0][1].top * partsRowBytes) + 			((long)theDoor.srcRects[0][1].left * (long)isDepth / 8L) + (long)offPartsPix;		theDoor.srcAddrs[1][0] = ((long)theDoor.srcRects[1][0].top * partsRowBytes) + 			((long)theDoor.srcRects[1][0].left * (long)isDepth / 8L) + (long)offPartsPix;		theDoor.srcAddrs[1][1] = ((long)theDoor.srcRects[1][1].top * partsRowBytes) + 			((long)theDoor.srcRects[1][1].left * (long)isDepth / 8L) + (long)offPartsPix;		theDoor.screenDestAddr[0] = ((long)theDoor.destRects[0].top * (long)screenRowBytes) + 			((long)theDoor.destRects[0].left * (long)isDepth / 8L) + screenBase + 			insetBytes;		theDoor.screenDestAddr[1] = ((long)theDoor.destRects[1].top * (long)screenRowBytes) + 			((long)theDoor.destRects[1].left * (long)isDepth / 8L) + screenBase + 			insetBytes;		theDoor.workDestAddr[0] = ((long)theDoor.destRects[0].top * workRowBytes) + 			((long)theDoor.destRects[0].left * (long)isDepth / 8L) + (long)offWorkPix;		theDoor.workDestAddr[1] = ((long)theDoor.destRects[1].top * workRowBytes) + 			((long)theDoor.destRects[1].left * (long)isDepth / 8L) + (long)offWorkPix;		theDoor.backDestAddr[0] = ((long)theDoor.destRects[0].top * backRowBytes) + 			((long)theDoor.destRects[0].left * (long)isDepth / 8L) + (long)offBackPix;		theDoor.backDestAddr[1] = ((long)theDoor.destRects[1].top * backRowBytes) + 			((long)theDoor.destRects[1].left * (long)isDepth / 8L) + (long)offBackPix;		for (i = 0; i < 9; i++)	{		playerSrcAddrs[i][0] = ((long)playerSrcRects[i][0].top * partsRowBytes) + 			((long)playerSrcRects[i][0].left * (long)isDepth / 8L) + (long)offPartsPix;		playerSrcAddrs[i][1] = ((long)playerSrcRects[i][1].top * partsRowBytes) + 			((long)playerSrcRects[i][1].left * (long)isDepth / 8L) + (long)offPartsPix;		playerSrcAddrs[i][2] = ((long)playerSrcRects[i][2].top * partsRowBytes) + 			((long)playerSrcRects[i][2].left * (long)isDepth / 8L) + (long)offPartsPix;				maskAddrs[i][0] = ((long)playerSrcRects[i][0].top * maskCRowBytes) + 			((long)playerSrcRects[i][0].left * (long)isDepth / 8L) + (long)offMaskPix;		maskAddrs[i][1] = ((long)playerSrcRects[i][1].top * maskCRowBytes) + 			((long)playerSrcRects[i][1].left * (long)isDepth / 8L) + (long)offMaskPix;		maskAddrs[i][2] = ((long)playerSrcRects[i][2].top * maskCRowBytes) + 			((long)playerSrcRects[i][2].left * (long)isDepth / 8L) + (long)offMaskPix;				opponentSrcAddrs[i][0] = ((long)opponentSrcRects[i][0].top * partsRowBytes) + 			((long)opponentSrcRects[i][0].left * (long)isDepth / 8L) + (long)offPartsPix;		opponentSrcAddrs[i][1] = ((long)opponentSrcRects[i][1].top * partsRowBytes) + 			((long)opponentSrcRects[i][1].left * (long)isDepth / 8L) + (long)offPartsPix;		opponentSrcAddrs[i][2] = ((long)opponentSrcRects[i][2].top * partsRowBytes) + 			((long)opponentSrcRects[i][2].left * (long)isDepth / 8L) + (long)offPartsPix;				fadeMaskAddrs[i][0] = ((long)fadeMaskRects[i][0].top * maskCRowBytes) + 			((long)fadeMaskRects[i][0].left * (long)isDepth / 8L) + (long)offMaskPix;		fadeMaskAddrs[i][1] = ((long)fadeMaskRects[i][1].top * maskCRowBytes) + 			((long)fadeMaskRects[i][1].left * (long)isDepth / 8L) + (long)offMaskPix;		fadeMaskAddrs[i][2] = ((long)fadeMaskRects[i][2].top * maskCRowBytes) + 			((long)fadeMaskRects[i][2].left * (long)isDepth / 8L) + (long)offMaskPix;	}		ballSrcAddr = ((long)theBall.srcRect.top * partsRowBytes) + 			((long)theBall.srcRect.left * (long)isDepth / 8L) + (long)offPartsPix;	ballMaskAddr = ((long)theBall.srcRect.top * maskCRowBytes) + 			((long)theBall.srcRect.left * (long)isDepth / 8L) + (long)offMaskPix;		boardCursor.srcAddr = ((long)boardCursor.srcRect.top * partsRowBytes) + 			((long)boardCursor.srcRect.left * (long)isDepth / 8L) + (long)offPartsPix;	boardCursor.maskAddr = ((long)boardCursor.srcRect.top * maskCRowBytes) + 			((long)boardCursor.srcRect.left * (long)isDepth / 8L) + (long)offMaskPix;		replaySrc = ((long)replayRect.top * workRowBytes) + 			((long)replayRect.left * (long)isDepth / 8L) + (long)offWorkPix;		replayDest = ((long)replayRect.top * (long)screenRowBytes) + 			((long)replayRect.left * (long)isDepth / 8L) + screenBase + insetBytes;}/*========================================================  GetBaseAddress1  */void GetBaseAddress1 (void){	long			insetHPix, insetVPix;	short			i;		screenBase = (long)screenBits.baseAddr;	screenRowBytes = screenBits.rowBytes;		insetHPix = (long)(screenBits.bounds.right - screenBits.bounds.left - screenWide) / 2L;	insetVPix = (long)(screenBits.bounds.bottom - screenBits.bounds.top - screenHigh) / 2L;	insetBytes = (insetVPix * (long)screenRowBytes) + (insetHPix / 8L);		for (i = 0; i < 480; i++)		screenRowAddrs[i] = ((long)screenRowBytes * (long)i) + screenBase + 				(long)insetBytes;		for (i = 0; i < 480; i++)		workRowOffsets[i] = (long)workRowBytes * (long)i;		theDoor.srcAddrs[0][0] = ((long)theDoor.srcRects[0][0].top * partsRowBytes) + 			((long)theDoor.srcRects[0][0].left / 8L) + (long)offPartsBits.baseAddr;		theDoor.srcAddrs[0][1] = ((long)theDoor.srcRects[0][1].top * partsRowBytes) + 			((long)theDoor.srcRects[0][1].left / 8L) + (long)offPartsBits.baseAddr;		theDoor.srcAddrs[1][0] = ((long)theDoor.srcRects[1][0].top * partsRowBytes) + 			((long)theDoor.srcRects[1][0].left / 8L) + (long)offPartsBits.baseAddr;		theDoor.srcAddrs[1][1] = ((long)theDoor.srcRects[1][1].top * partsRowBytes) + 			((long)theDoor.srcRects[1][1].left / 8L) + (long)offPartsBits.baseAddr;		theDoor.screenDestAddr[0] = ((long)theDoor.destRects[0].top * (long)screenRowBytes) + 			((long)theDoor.destRects[0].left / 8L) + screenBase + insetBytes;		theDoor.screenDestAddr[1] = ((long)theDoor.destRects[1].top * (long)screenRowBytes) + 			((long)theDoor.destRects[1].left / 8L) + screenBase + insetBytes;		theDoor.workDestAddr[0] = ((long)theDoor.destRects[0].top * workRowBytes) + 			((long)theDoor.destRects[0].left / 8L) + (long)offWorkBits.baseAddr;		theDoor.workDestAddr[1] = ((long)theDoor.destRects[1].top * workRowBytes) + 			((long)theDoor.destRects[1].left / 8L) + (long)offWorkBits.baseAddr;		theDoor.backDestAddr[0] = ((long)theDoor.destRects[0].top * backRowBytes) + 			((long)theDoor.destRects[0].left / 8L) + (long)offBackBits.baseAddr;		theDoor.backDestAddr[1] = ((long)theDoor.destRects[1].top * backRowBytes) + 			((long)theDoor.destRects[1].left / 8L) + (long)offBackBits.baseAddr;		for (i = 0; i < 9; i++)	{		playerSrcAddrs[i][0] = ((long)playerSrcRects[i][0].top * partsRowBytes) + 			((long)playerSrcRects[i][0].left / 8L) + (long)offPartsBits.baseAddr;		playerSrcAddrs[i][1] = ((long)playerSrcRects[i][1].top * partsRowBytes) + 			((long)playerSrcRects[i][1].left / 8L) + (long)offPartsBits.baseAddr;		playerSrcAddrs[i][2] = ((long)playerSrcRects[i][2].top * partsRowBytes) + 			((long)playerSrcRects[i][2].left / 8L) + (long)offPartsBits.baseAddr;				maskAddrs[i][0] = ((long)playerSrcRects[i][0].top * maskRowBytes) + 			((long)playerSrcRects[i][0].left / 8L) + (long)offMaskMap.baseAddr;		maskAddrs[i][1] = ((long)playerSrcRects[i][1].top * maskRowBytes) + 			((long)playerSrcRects[i][1].left / 8L) + (long)offMaskMap.baseAddr;		maskAddrs[i][2] = ((long)playerSrcRects[i][2].top * maskRowBytes) + 			((long)playerSrcRects[i][2].left / 8L) + (long)offMaskMap.baseAddr;				opponentSrcAddrs[i][0] = ((long)opponentSrcRects[i][0].top * partsRowBytes) + 			((long)opponentSrcRects[i][0].left / 8L) + (long)offPartsBits.baseAddr;		opponentSrcAddrs[i][1] = ((long)opponentSrcRects[i][1].top * partsRowBytes) + 			((long)opponentSrcRects[i][1].left / 8L) + (long)offPartsBits.baseAddr;		opponentSrcAddrs[i][2] = ((long)opponentSrcRects[i][2].top * partsRowBytes) + 			((long)opponentSrcRects[i][2].left / 8L) + (long)offPartsBits.baseAddr;				fadeMaskAddrs[i][0] = ((long)fadeMaskRects[i][0].top * maskRowBytes) + 			((long)fadeMaskRects[i][0].left / 8L) + (long)offMaskMap.baseAddr;		fadeMaskAddrs[i][1] = ((long)fadeMaskRects[i][1].top * maskRowBytes) + 			((long)fadeMaskRects[i][1].left / 8L) + (long)offMaskMap.baseAddr;		fadeMaskAddrs[i][2] = ((long)fadeMaskRects[i][2].top * maskRowBytes) + 			((long)fadeMaskRects[i][2].left / 8L) + (long)offMaskMap.baseAddr;	}		ballSrcAddr = ((long)theBall.srcRect.top * partsRowBytes) + 			((long)theBall.srcRect.left / 8L) + (long)offPartsBits.baseAddr;	ballMaskAddr = ((long)theBall.srcRect.top * maskRowBytes) + 			((long)theBall.srcRect.left / 8L) + (long)offMaskMap.baseAddr;		boardCursor.srcAddr = ((long)boardCursor.srcRect.top * partsRowBytes) + 			((long)boardCursor.srcRect.left / 8L) + (long)offPartsBits.baseAddr;	boardCursor.maskAddr = ((long)boardCursor.srcRect.top * maskRowBytes) + 			((long)boardCursor.srcRect.left / 8L) + (long)offMaskMap.baseAddr;		replaySrc = ((long)replayRect.top * workRowBytes) + 			((long)replayRect.left / 8L) + (long)offWorkBits.baseAddr;		replayDest = ((long)replayRect.top * (long)screenRowBytes) + 			((long)replayRect.left / 8L) + screenBase + insetBytes;}/*========================================================  LoadSounds  */void LoadSounds (void){	Str255			fileName;	Handle			theSound, memoryBuffer;	short			i;		GetSoundVol(&wasSoundVolume);	SetSoundVol(soundVolume);		soundPriorities[0] = 0;	soundPriorities[kClashSound] = kClashPriority;	soundPriorities[kRicochetSound] = kRicochetPriority;	soundPriorities[kScoreSound] = kScorePriority;	soundPriorities[kBallFiringSound] = kBallFiringPriority;	soundPriorities[kBeamInSound] = kBeamInPriority;	soundPriorities[kBeamOutSound] = kBeamOutPriority;	soundPriorities[kFoulSound] = kFoulPriority;	soundPriorities[kBallPickUpSound] = kBallPickUpPriority;	soundPriorities[kCrowdSound] = kCrowdPriority;	soundPriorities[kCrowdSwellSound] = kCrowdSwellPriority;	soundPriorities[kApplauseSound] = kApplausePriority;	soundPriorities[kCrowdFadeSound] = kCrowdFadePriority;	soundPriorities[kBellSound] = kBellPriority;	soundPriorities[kMobSwellSound] = kMobSwellPriority;	soundPriorities[kMobSound] = kMobPriority;	soundPriorities[kMobFadeSound] = kMobFadePriority;	soundPriorities[kHoldingSound] = kHoldingPriority;	soundPriorities[kGameSound] = kGamePriority;	soundPriorities[kPointSound] = kPointPriority;	soundPriorities[kBallDropSound] = kBallDropPriority;	soundPriorities[kBrakeSound] = kBrakePriority;	soundPriorities[kAllSound] = kAllPriority;	soundPriorities[kTiedSound] = kTiedPriority;	soundPriorities[kIdleSound] = kIdlePriority;	soundPriorities[kOverSound] = kOverPriority;		memoryBuffer = NewHandle(65536L);	if (memoryBuffer == kNilPointer)		DeathError(kErrNoMemory);		for (i = 1; i < kMaxNumberOfSounds; i++)	{		theSound = GetResource('SMSD', i);		if (theSound != kNilPointer)		{			MoveHHi(theSound);			HLock(theSound);			HNoPurge(theSound);			soundLoaded[i] = TRUE;		}		else			soundLoaded[i] = FALSE;	}		soundFileRefNum = -1;	GetIndString(fileName, rMiscStrings, 6);	if (fileName[0] != 0)	{		soundFileRefNum = OpenResFile((StringPtr)StripAddress((Ptr)fileName));		UseResFile(soundFileRefNum);				for (i = kMaxNumberOfSounds; i <= kLastIncidentalSounds; i++)		{			theSound = GetResource('SMSD', i);			if (theSound != kNilPointer)			{				MoveHHi(theSound);				HLock(theSound);				HNoPurge(theSound);				incidentSoundLoaded[i - kMaxNumberOfSounds] = TRUE;			}			else				incidentSoundLoaded[i - kMaxNumberOfSounds] = FALSE;		}	}		DisposeHandle(memoryBuffer);}/*========================================================  SpeedTest  */void SpeedTest (void){	long		thisTime;		speedFlag = 0L;	thisTime = LMGetTicks();	while (thisTime == LMGetTicks());	thisTime += 15L;	while (thisTime >= LMGetTicks())	{		TwinkleAStar();		speedFlag++;	}}/*========================================================  InitializeAll  */void InitializeAll (void){	short			netErr;	Boolean			wereLegit;		ToolBoxInit();	CheckOurEnvirons();	LoadCursors();	LoadThePreferences();		#if kDemoVersion		canNetwork = FALSE;	#else		if (!netOnly)		{			wereLegit = ValidInstallation(TRUE);			if (wereLegit)			{				netOnly = FALSE;			}			else			{				encryptedNumber = 0L;				netOnly = TRUE;			}		}				if (netOnly)		{			thePlayer.persona = kHumanPlayer;			theOpponent.persona = kNetHuman;			whichGame = kStandardGame;		}				netErr = InitializeAppleTalk();		if (netErr == kNetErrNoErr)			canNetwork = TRUE;		else		{			canNetwork = FALSE;			if (netOnly)			{				MinorError(kMinorCantNetAndNetOnly);			}			else if (theOpponent.persona == kNetHuman)			{				theOpponent.persona = kMissTeak;				MinorError(kMinorCantNetDefault);			}		}	#endif		LoadLargeDataStructures();	VarInit();	InitBallData();	InitPlayerData();	InitOpponentData();	InitDigiDispData();	OpenMainWindow();	DoSplashScreen();	if (isColor)		PixMap4Init();	else		BitMapInit();	if ((!useQD) && (isColor))		MaskPixInit();	MaskMapInit();	if (isColor)		GetBaseAddressC();	else		GetBaseAddress1();	WhosOnFirst();	UpdateGoalPicts(FALSE);	MenuBarInit();	LoadSounds();	SpeedTest();	FlushEvents(everyEvent, kRemoveAllEvents);}